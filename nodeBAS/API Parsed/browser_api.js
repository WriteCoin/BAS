/**
* Закрыть вкладку (BAS-функция)
* Закрыть вкладку с указанным индексом.
* @param {number} index Номер Вкладки
* @param {Function} callback Функция
*/
function BAS_popup_close(index, callback) {
const index = _function_argument('index') || index
const callback = _function_argument('callback') || function() {}
popupclose(index)!
}
/**
* Загрузить (async)
* Загружает указанный URL в браузере. Примеры: загрузить google.com, загрузить instagram.com.
*Если вы столкнулись с ошибками во время выполнения этого действия, попробуйте снять флажок "Ждать полной загрузки страницы" (waiter_timeout_next) или обернуть действие загрузки в блок игнорирования ошибок.
* @param text Url сайта
* @param referrer Referrer. Может быть пустым
* @param is_instant Ждать полной загрузки страницы после этого действия
* @param callback
*/
function BAS_load(text, referrer, is_instant, callback) {
const text = _function_argument('text') || text
const referrer = _function_argument('referrer') || (referrer || '')
const is_instant = _function_argument('is_instant') || is_instant
const callback = _function_argument('callback') || (callback || function() {})
_load(text, referrer, is_instant, callback)!
}
/**
* Максимальное время выполнения задания (следующего действия). Используйте действие 'Таймаут' (функция general_timeout) чтобы установить максимальное время ожидания по умолчанию.
* @param timeout максимальное время выполнения задания, в миллисекундах (следующего действия)
*/
function BAS_general_timeout_next(timeout) {
const timeout = _function_argument('timeout') || timeout
general_timeout_next(timeout)
}
/**
* BAS ограничивает время выполнения каждого действия. Никакое действие не может длиться вечно, кроме сна и ручного решения капчи, но вы можете настроить лимиты.
* По умолчанию максимальное время решения капчи в неручном режиме составляет 120 секунд и 60 секунд для каждого другого действия.
* Чтобы изменить максимальное время решения капчи, выполните это действие с типом таймаута "Solver".
* Чтобы изменить максимальное время решения капчи, выполните это действие с типом таймаута "Solver".
* BAS позволяет установить таймаут для каждого действия индивидуально, для этого щелкните на значок песочных часов возле кнопки отмены внутри интерфейса конкретного действия.
* @param timeout Таймаут в миллисекундах
*/
function BAS_general_timeout(timeout) {
const timeout = _function_argument('timeout') || timeout
general_timeout(timeout)
}
/**
* @param timeout Таймаут в миллисекундах
*/
function BAS_async_load_timeout(timeout) {
const timeout = _function_argument('timeout') || timeout
async_load_timeout(timeout)
}
/**
* Изменить максимальное время решения капчи
* @param timeout Таймаут в миллисекундах
*/
function BAS_solver_timeout(timeout) {
const timeout = _function_argument('timeout') || timeout
solver_timeout(timeout)
}
/**
* Текущий Url (async)
* Получить текущий url из адресной строки браузера.
* Получать из функции _result()
*/
function BAS_url() {
url()!
const result = _result()
_function_return(result)
return result
}
/**
* Предыдущая Страница (async)
* Открыть предыдущий url.
* Это действие работает так же, как нажатие на кнопку "Назад" в браузере.
* Если текущая страница загружена первой, это действие загрузит пустую страницу.
* @param is_instant Не ждать полной загрузки страницы (добавлять wait_async_load и waiter_timeout_next соответственно)
* @param callback Функция
*/
function BAS_navigate_back(is_instant, timeout, callback) {
const is_instant = _function_argument('is_instant') || is_instant
const timeout = _function_argument('timeout') || timeout
const callback = _function_argument('callback') || (callback || function() {})
if (timeout) {
waiter_timeout_next(timeout)
}
navigate_back(is_instant, callback)!
if (!is_instant) {
wait_async_load()!
}
}
/**
* Ввод текста в элемент с фокусом (async)
* Если вы хотите ввести текст в определенный элемент, кликните по нему и выберите "Ввод Текста".
* Это действие может вводить любые символы включая специальные клавиши, такие как enter, backspace, insert, delete и т. д.
* Если вы хотите ввести большой текст, используйте 0 интервал или действие "Запись В Буфер Обмена" и ввод <CONTROL>V
* Ctrl = <CONTROL>, Alt = <MENU>, Shift = <SHIFT>, Backspace = <BACK>, tab = <TAB>, Enter = <RETURN>, Escape = <ESCAPE>, Page up = <PRIOR>, Page down = <NEXT>, End = <END>, home = <HOME>, Left = <LEFT>, Up = <UP>, Right = <RIGHT>, Down = <DOWN>, Insert = <INSERT>, Delete = <DELETE>, Mouse wheel up = <MOUSESCROLLUP>, Mouse wheel down = <MOUSESCROLLDOWN>
* Добавлять wait_async_load()! для полной загрузки страницы после этого действия
* Добавлять waiter_timeout_next(timeout) для задания максимального времени выполнения этого действия
* @param text Текст для ввода
* @param interval Интервал в миллисекундах
*/
function BAS_type(text, interval, is_instant, timeout) {
const text = _function_argument('text') || text
const interval = _function_argument('interval') || interval
const is_instant = _function_argument('is_instant') || is_instant
const timeout = _function_argument('timeout') || timeout
if (timeout) {
waiter_timeout_next(timeout)
}
_type(text, interval)!
if (!is_instant) {
wait_async_load()!
}
}
/**
* Разрешение (async)
* Изменяет разрешение браузера. Стандартное значение 1024x600. Если вы хотите получить стандартные разрешения для разных платформ, используйте сервис fingerprint switcher.
* @param x Ширина
* @param y Высота
* @param callback Функция
*/
function BAS_resize(x, y, callback) {
const x = _function_argument('x') || x
const y = _function_argument('y') || y
const callback = _function_argument('callback') || (callback || function() {})
resize(x, y, callback)!
}
/**
* Получить разрешение и положение курсора (async)
* Возвращает: Положение курсора X, Положение курсора Y, Положение прокрутки X, Положение прокрутки Y, Ширина бразуера, Высота браузера
* Получить текущий размер браузера, положение курсора и прокрутки.
* Чтобы изменить размеры браузера, используйте действие "Разрешение".
* Чтобы изменить текущее положение прокрутки, используйте действие "Прокрутка".
* Чтобы изменить текущее положение курсора, используйте действие "Двигать Мышь".
*/
function BAS_get_browser_screen_settings() {
_get_browser_screen_settings()!
const result = _result()
_function_return(result)
return result
}
/**
* Сброс (proxy)
* Очистите все данные браузера: прокси, user-agent, заголовки, фильтры БАС, данные кэша БАС, cookie.
* Не вызывайте это действие при запуске потока, BAS автоматически очистит данные самостоятельно.
*/
function BAS_new_browser(callback) {
const callback = _function_argument('callback') || (callback || function() {})
new_browser(callback)!
}
/**
* Диалог Открыть Файл (async)
* Загрузка файла выполняется в два этапа: установка следующего результата диалога открытия файла с помощью этого действия и нажатия на элемент, который запускает загрузку, например кнопку "Загрузить".
* Вы всегда должны вызывать это действие перед началом загрузки, иначе BAS не будет знать, какой файл ему нужно отправить в браузер.
* Используйте ресурс с типом "Файлы из папки" для загрузки всех файлов из папки и распределения их по потокам.
* @param text Путь к файлу, который будет результатом вызова диалога открытия файла. Этот параметр - строка с путем к файлу. Тип разделителя значения не имеет. Это также может быть json массив с несколькими файлами, смотрите примеры. В этом случае BAS действует, как если бы пользователь выбрал несколько файлов.
* Примеры: C:\file\path.txt; C:/file/path.txt; ["C:/file/path1.txt", "C:/file/path2.txt"]
* @param callback функция
*/
function BAS_open_file_dialog(text, callback) {
const text = _function_argument('text') || text
const callback = _function_argument('callback') || (callback || function() {})
open_file_dialog(text, callback)!
}
/**
* Начать Перетягивать Файл (async)
* Это действие является альтернативой "Диалог Открыть Файл" с одной разницей - оно перетаскивает файл в браузер вместо открытия диалога.
* Вызов этого действия аналогичен началу перетаскивания файла в обычном браузере.
* Не забудьте закончить перетягивание с помощью действия Закончить Перетаскивание или Закончить Перетаскивание На Элементе.
* @param text Путь к файлу для начала перетягивания. Этот параметр - строка с путем к файлу. Тип разделителя значения не имеет. Примеры: C:\file\path.txt; C:/file/path.txt
* @param callback функция
*/
function BAS_drag_file(text, callback) {
const text = _function_argument('text') || text
const callback = _function_argument('callback') || (callback || function() {})
drag_file(text, callback)!
}
/**
* Окно "prompt" (async)
* Prompt отображает диалоговое окно с необязательным запросом на ввод текста. Это устаревшая функциональность, и большинство сайтов больше не используют ее. BAS позволяет автоматически вводить текст в это окно, для этого вы должны вызвать действие до появления диалога.
* Принцип такой же, как в "Диалог Открыть Файл", сначала вы вызываете действие, которое задает результат, а потом запускаете диалог, BAS распознает его и вводит ранее установленное значение.
* @param text Результат ввода
* @param callback функция
*/
function BAS_prompt_result(text, callback) {
const text = _function_argument('text') || text
const callback = _function_argument('callback') || (callback || function() {})
prompt_result(text, callback)!
}
/**
* HTTP Аутентификация (async)
* HTTP аутентификация предоставляет метод для ввода логина и пароля от сайта. В настоящее время он редко используется, но некоторые сайты все еще полагаются на него. Во время аутентификации браузер показывает окно, и пользователь должен ввести данные. Этот процесс может быть автоматизирован, все, что вам нужно сделать, - это вызвать данное действие до отображения окна.
* Хорошей идеей было бы поставить действие в начало сценария.
* В случае, если оно будет вызвано после отображения окна, аутентификация работать не будет.
* @param login HTTP Аутентификация логин
* @param pass HTTP Аутентификация пароль
* @param callback функция
*/
function BAS_http_auth_result(login, pass, callback) {
const login = _function_argument('login') || login
const pass = _function_argument('pass') || pass
const callback = _function_argument('callback') || (callback || function() {})
http_auth_result(login, pass, callback)!
}
/**
* Прокрутка (async)
* Прокрутка браузера. Цель этого действия - сделать указанные координаты видимыми на экране.
* Оно не перемещает левый верхний угол в заданное положение, просто гарантирует, что определенная позиция видна на экране. Если координаты уже видны, то это действие ничего не сделает, иначе оно будет прокручивать окно таким образом, чтобы координаты располагались как можно ближе к центру.
* Если вы хотите, чтобы определенный элемент, а не координаты, был видимым, вместо этого действия используйте "Прокрутка К Элементу".
* Если выбрана настройка "Использовать колесо мыши или касания", прокрутка будет выполнена так, как если бы ее делал реальный человек. Колесо мыши будет использоваться для настольного ПК и касания для сенсорного экрана в мобильном телефоне. Если флажок не установлен, прокрутка будет выполняться мгновенно.
* Если вы хотите прокрутить страницу в самый низ, используйте следующие настройки: "X координата" = 0, "Y координата" = 999999.
* Установка полного времени ожидания: вызовы waiter_timeout_next(timeout) и wait_async_load()! после вызова этой функции
* @param target смещение Y координаты
* @param callback функция
*/
function BAS_scroll_to(target, callback) {
const target = _function_argument('target') || target
const callback = _function_argument('callback') || (callback || function() {})
_scroll_to(target, callback)!
}
/**
* Скриншот (async)
* Это действие делает скриншот выбранной части экрана и сохраняет его в изображении в формате png, закодированном как строка base64.
* Если выбранная область не видна, страница будет прокручена.
* Координаты X и Y задаются в абсолютном смещении от краев страницы.
* Если вы хотите сделать скриншот определенного элемента, нажмите на него и выберите действие "Скриншот".
* Если вы хотите сделать снимок всей страницы, нажмите на любой элемент в браузере и используйте действие "Скриншот" с селектором >CSS> body.
* Результат после выполнения этого действия хранится в функции _result
* @param x X
* @param y Y
* @param width Ширина
* @param height Высота
* @param callback функция
*/
function BAS_render(x, y, width, height, callback) {
const x = _function_argument('x') || x
const y = _function_argument('y') || y
const width = _function_argument('width') || width
const height = _function_argument('height') || height
const callback = _function_argument('callback') || (callback || function() {})
render(x, y, width, height, callback)!
}
/**
* Recaptcha V3
* Это действие решает google recaptcha 3.0.
* Recaptcha v3, в отличие от других капч, не показывает изображения и не требует от пользователя какого-либо взаимодействия. Она работает абсолютно незаметно. Поэтому ее можно разместить в нескольких местах на сайте или даже на каждой странице. При переходе на страницу или при вызове события, к которым прикреплена Recaptcha v3, сайт получает рейтинг браузера. Рейтинг отражает вероятность того, что посетитель сайта является ботом.
* Сайт может использовать результат по своему усмотрению. Например, один сайт может показывать капчу, если рейтинг пользователя ниже 0.4, на другом сайте может потребоваться проверка телефона, если оценка ниже 0.6, и пользователь будет заблокирован, если она ниже 0.3.
* Это действие перехватывает запрос верификации пользователя сайтом и отправляет его в указанный сервис. Когда сервис вернет результат, он заменит реальный рейтинг браузера на то, что был получен от одного из работников выбранного сервиса.
* ВАЖНО: Это действие само по себе не решает капчи, вместо этого оно устанавливает параметры решения Recaptcha v3 для последующих вызовов. Следовательно, оно должно быть вызвано до того, как появится Recaptcha v3.
* Каждый сайт имеет свои требования к минимальному рейтингу, вы можете настроить ожидаемое значение, изменив параметр 'Минимальный рейтинг'.
* Recaptcha v3 может быть размещена на всех страницах сайта. В таком случае, каждая страница будет иметь свое собственное действие. Например, могут быть действия для посещения страницы с ценами, посещения страницы c часто задаваемыми вопроcами и создание нового пользователя. Вы можете отключить перехват для второстепенных действий и включить его для важных, изменив параметр 'Название действия'.
* Чтобы найти точное название действия на конкретном сайте, вам необходимо зайти на страницу с требуемым действием, после чего появится сообщение с его названием.(screen). Все уже вызванные дейстия будут отображены в выпающем списке для параметра 'Название действия'.
* Использование сервиса требует ключа, который должен быть куплен на сайте сервиса и введен в поле "Ключ Rucaptcha/2captcha".
* В качестве альтернативы этому действию вы можете попытаться обойти Recapthca V3. Вот что влияет на итоговый рейтинг: профиль с авторизацией Gmail и историей поиска Google созданный некоторе время назад, хороший прокси, продолжительная история действий на сайте, с которым вы работаете. Остановимся подробнее на последнем пункте. Recaptcha v3 отслеживает ваши действия на каждом сайте, регистрируя каждое действие, которое вы выполняете. Например, если вы посещаете страницу покупок, ищете какой-то товар, посещаете страницу с часто задаваемыми вопросами и только после этого пытаетесь зарегистрировать учетную запись, это будет гораздо менее подозрительно, чем попытка зарегистрировать учетную запись немедленно, и с высокой вероятностью получит лучший результат.
* Существует еще один тип рекапчи, который называется невидимая рекапча. Он работает почти так же, как Recaptcha v3, но вместо того, чтобы возвращать рейтинг пользователя, он показывает изображение, если пользователь кажется подозрительным, это эквивалентно низкому рейтингу. BAS также может решать невидимую рекапчу, для этого используйте действие 'Решить Recaptcha 2.0'.(видео https://www.youtube.com/watch?v=ltWy6O9jsTo).
* @param action Название действия. Содержит одно или несколько действий recaptcha v3. Это поле может содержать несколько действий разделенный запятыми. Когда браузер выполнит одно из этих действий, запрос оценки рейтинга будет перехвачен и отправлен службе, выбранной в поле "Метод решения". По умолчанию абсолютно все запросы будут перехвачены, но вы можете настроить это поле для отправки только нужных действий.
* Примеры:
* * - Перехватывать все действия
* Action 1 - Перехватывать только 'Action 1', все остальные действия будут возвращать реальный рейтинг браузера.
* Action 1, Action 2 - Перехватывать только 'Action 1' и 'Action 2', все остальные действия будут возвращать реальный рейтинг браузера.
* ВНИМАНИЕ: между дейтвиями не должно быть пробелов.
* @param method Метод решения. Это строка, вы можете установить значение напрямую или использовать переменную или ресурс.
* Примеры:
* antigate - Решить с помощью сервиса http://anti-captcha.com/
* rucaptcha - Решить с помощью сервиса http://rucaptcha.com/
* 2captcha - Решить с помощью сервиса http://2captcha.com/
* disable - Перестать перехватывать запросы.
* Сайт получит ваш реальный рейтинг. Вы можете снова включить перехват позже.
* @param rucaptcha Ключ Антигейт/Рукапча. Может быть пустым. Это ключ от сервиса, выбранного в поле "Метод решения".
* @param serverurl Url сервера. Может быть пустым.
* Примеры:
* http://127.0.0.3:8083/
* Пустая строка - Использовать url по умолчанию, например, http://rucaptcha.com для rucaptcha.
* @param score Минимальный рейтинг, с которым должен приходить ответ от сервиса. 0.1 - самый низкий рейтинг, 0.9 - самый высокий. Это зависит от сайта, хочет ли он пропускать браузеры с данным рейтингом или нет. 0.6 - это значение по умолчанию, оно должно быть приемлемым для большинства сайтов.
* Примеры:
* 0.3
* 0.7
* @param use_proxy Отправлять текущий прокси на сервис. Заставляет работника, который решает капчу, использовать прокси, который вы настроили с помощью действия "Прокси".
* Примеры:
* true - Отправлять текущий прокси на сервис. Значение прокси получается из действия "Прокси".
* false - Не отправлять прокси. Стандартное значение.
* @param callback функция
*/
function BAS_recaptcha_v3() {
const action = _function_argument('action')
const method = _function_argument('method')
const rucaptcha = _function_argument('rucaptcha')
const serverurl = _function_argument('serverurl')
const score = _function_argument('score')
const use_proxy = _function_argument('use_proxy')
const callback = _function_argument('callback') || function() {}
_recaptchav3(action, method, rucaptcha, serverurl, score, use_proxy, callback)
}
/**
* Решить капчу кликами (BAS-функция, вызов через _call_function)
* Решить любой тип капчи, который требует кликать по изображениям.
* Для решения ReCaptcha и HCaptcha рекомендуется использовать действия Решить Recaptcha 2.0 и Решить HCaptcha из контекстного меню браузера, если это возможно. С ними проще работать, и капча может решиться быстрее. Также эти действия позволяют выполнять автоматическую валидацию решения. Используйте это действие, если другие варианты не подходят вам по каким-либо причинам.
* Это действие позволяет вам решить любую капчу, которая требует, чтобы вы нажимали на изображения в соответствии с определенными инструкциями. Это может быть ReCaptcha, HCaptcha и другие типы. Для решения таких капч необходимо отправить на сервис изображение, содержащее элементы, по которым нужно выполнить клики. Если на капче или рядом с ней присутствует описание, рекомендуется отправлять его вместе с изображением, чтобы избежать неверных решений.
* Данное действие не выполняет автоматических кликов по координатам, в отличие от действия Решить капчу кликами из контекстного меню браузера, которое делает всё без вашего участия. Использовать его будет намного проще.
* После того, как сервис решит капчу, вы получите список координат, по которым необходимо будет выполнить клики. Для того, чтобы выполнить клики, данный список необходимо пройти любым циклом, например for или foreach, и на каждой итерации вызвать действие Кликнуть для каждой пары координат X и Y. После выполнения кликов вам необходимо вручную продолжить работу. То есть, вы должны сами выполнить подтверждение решения или перейти к следующему изображению.
* Для всех сервисов требуется сервисный ключ, который должен быть получен на сайте сервиса и введён в поле Ключ сервиса.
* Для выполнения кликов по полученным координатам вам нужно учитывать позицию элемента, скриншот которого вы отправляете, относительно страницы, а также скролл по вертикали и горизонтали. Поэтому самым простым вариантом будет использование аналогичного действия для конкретного элемента из контекстного меню браузера, где клики будут выполняться автоматически.
* Важный момент - данное действие не выполняет автоматического подтверждения решения капчи. Вы должны сделать это сами. Например, если вы решаете ReCaptcha2 используя данный метод, то вам нужно самостоятельно выполнить клик по чекбоксу, а после выполнения кликов по координатам - нажать на кнопку Далее или Готово.
* Параметр Интервал проверки решения задачи отвечает за частоту отправки запросов на сервис для проверки решения капчи. Чем больше вы выставите значение, тем дольше BAS будет ожидать перед тем, как отправить очередной запрос. Рекомендуется использовать задержку не менее 5 секунд.
* Параметр Задержка проверки решения задачи отвечает за длительность ожидания перед тем, как BAS начнет проверку капчи. Сначала капча отправляется на сервис, после этого BAS будет ожидать указанное время, по прошествии которого начнется непосредственно проверка состояния задачи. Большинство сервисов рекомендуют подождать не менее 5 секунд.
* Если нужного сервиса нет в списке доступных, но он работает через API аналогичный выбранному сервису, вы можете указать необходимый URL сервера в поле URL сервиса, находящееся в дополнительных настройках.
* Если вы используете такие программы, как CapMonster, XEvil или аналоги, вы должны заполнить поле URL сервиса в соответствии с документацией к данному ПО.
* Подробную документацию по решению подобных капч можно посмотреть здесь. https://rucaptcha.com/api-rucaptcha#solving_clickcaptcha
* Второй аргумент - объект с параметрами:
*
* textInstructions - Описание капчи. Может быть пустым. Если у captcha есть какое-либо описание, его можно добавить в это поле.
* Примеры:
* Выберите все изображения, на которых есть самолёт
* Выберите все изображения, на которых есть лодка
*
* dataBase64 - Данные изображения в base64. Данные в формате base64, их можно получить из действия скриншот или из действия читать файл.
*
* taskWaitTimeout - Интервал проверки решения задачи в миллисекундах. С помощью этого параметра вы можете контролировать длительность паузы между каждой новой проверкой решения капчи.
* Примеры:
* 600 - Ждать в течение 600 миллисекунд
* 10000 - Ждать в течение 10 секунд
* 5000 - Ждать в течение 5 секунд
*
* taskWaitDelay - Задержка проверки решения задачи в миллисекундах. С помощью этого параметра вы можете контролировать длительность паузы между отправкой капчи на сервис и началом ожидания решения. Чаще всего, сервисы решения капчи указывают необходимое время ожидания, в остальных случаях вы можете указать любое удобное для вас значение.
* Примеры:
* 600 - Ждать в течение 600 миллисекунд
* 10000 - Ждать в течение 10 секунд
* 5000 - Ждать в течение 5 секунд
*
* serviceName - Название сервиса для решения капчи
* Примеры:
* rucaptcha - Решить капчу используя сервис https://rucaptcha.com/
* 2captcha - Решить капчу используя сервис https://2captcha.com/
*
* serviceUrl - URL сервиса. Может быть пустым. ВЫ можете использовать этот параметр, если нужного вам сервиса нет в списке доступных. В таком случае укажите название сервиса, котрый работает по аналогичному API, и используйте нужный вам адрес.
* Примеры:
* Пустая строка - Использовать стандартный URL сервиса, http://rucaptcha.com для RuCaptcha и так далее
* http://127.0.0.1:8083 - Использовать кастомный URL сервиса с портом 8083
* http://127.0.0.3:8080 - Использовать кастомный URL сервиса с портом 8080
*
* serviceKey - Ключ сервиса. Ключ от сервиса решения капчи. Вы можете получить его в личном кабинете выбранного сервиса решения капчи
*
* imageData - Данные изображения в base64. Их можно получить из действия скриншот или из действия читать файл.
*/
function BAS_solve_coordinates_captcha() {
const textInstructions = _function_argument('textInstructions') || ''
const dataBase64 = _function_argument('dataBase64')
const taskWaitTimeout = _function_argument('taskWaitTimeout')
const taskWaitDelay = _function_argument('taskWaitDelay')
const serviceName = _function_argument('serviceName') || 'rucaptcha'
const serviceUrl = _function_argument('serviceUrl') || ''
const serviceKey = _function_argument('serviceKey')
const imageData = _function_argument('imageData')
const params = {
textInstructions: textInstructions,
dataBase64: dataBase64,
taskWaitTimeout: taskWaitTimeout,
taskWaitDelay: taskWaitDelay,
serviceName: serviceName,
serviceUrl: serverUrl,
serviceKey: serviceKey,
imageData: imageData
}
_call_function(BASCaptchaSolver.solveCoordinatesCaptcha, params)!
}
/**
* Решено Неверно
* Используйте это действие, если прошлая капча была решена неправильно.
* На сервис отправляется запрос о неверном решении и деньги за решения не будут сняты со счета.
* Если последняя капча была решена без использования сервиса(с помощью софта или в ручном режиме), это действие не сделает ничего.
*/
function BAS_solver_failed() {
solver_failed()
}
/**
* Нажать кнопку расширения (async)
* Для ожидания полной загрузки страницы после этого действия - использовать wait_async_load()! после этого действия
* Для задания максимального времени выполнения задания - использовать waiter_timeout_next(timeout) после вызова этой функции
* Выполнение этого действия аналогично клику по данной кнопке https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=chrome_2021-05-15_12-50-15.png
* Перед использованием этого действия необходимо сначала установить расширение. Для этого используйте действие "Настройки браузера".
* Более подробную информацию об использовании расширений можно найти на этой странице https://wiki.bablosoft.com/doku.php?id=ru:using_extensions
* @param id Id или имя расширения
* Идентификатор или имя расширения. Нет необходимости вводить id целиком или полное имя, допускается использование только его части.
* Примеры:
* padekgcemlokbadohgkifijomclgjgif - Открыть интерфейс расширения padekgcemlokbadohgkifijomclgjgif.
* padekgcem - Открыть интерфейс расширения id которого содержит padekgcem.
* Proxy SwitchyOmega - Открыть интерфейс расширения найденного по имени.
* Proxy - Открыть интерфейс расширения найденного по части имени.
* @param callback Функция
*/
function BAS_click_extension_button(id, is_instant, timeout, callback) {
const id = _function_argument('id') || id
const is_instant = _function_argument('is_instant') || is_instant
const timeout = _function_argument('timeout') || timeout
const callback = _function_argument('callback') || (callback || function() {})
if (timeout) {
waiter_timeout_next(timeout)
}
_click_extension_button(id, callback)!
if (!is_instant) {
wait_async_load()!
}
}
/**
* Режим сенсорного экрана (async)
* Включить эмуляцию сенсорного экрана.
* Сенсорный экран будет включен автоматически после изменения отпечатка, поэтому это действие не требуется вызывать явно.
* В режиме cенсорного экрана браузер будет вести себя точно так же, как мобильный браузер: события движения мыши не будут отправляться, клики мыши будут заменены событиями касания, многие внутренние методы браузера также будут модифицированы, и т. д.
* Специальные клавиши, такие как TAB, CTRL или стрелки на клавиатуре, останутся функциональными, но браузер не будет получать никаких уведомлений об этих событиях.
* События колеса мыши будет заменено свайпами.
* @param mode mobile | desktop
* Использовать сенсорный экран. Включить эмуляцию сенсорного экрана для текущей сессии браузера.
* Примеры:
* mobile - Включить эмуляцию сенсорного экрана
* desktop - Десктопный режим
* @param callback Функция
*/
function BAS_browser_mode(mode, callback) {
const mode = _function_argument('mode') || mode
const callback = _function_argument('callback') || (callback || function() {})
_browser_mode(mode, callback)!
}
/**
* Настройки Мыши
* Это настройки перемещения мыши. Вы можете установить его либо глобально(посредством этого действия), либо для каждого действия индивидуально, нажав на значок настроек возле кнопки отмены внутри любого действия, которое использует мышь.
* @param params Объект с параметрами:
* speed - Скорость движения мыши как число с плавающей запятой, если вы меняете этот параметр, не забудьте изменить притяжение и отклонение пропорционально.
* gravity - Притяжение. Значение с плавающей запятой, которое устанавливает силу притяжения курсора к линии между начальной и конечной точками. Если вы установите слишком большое значение, курсор будет перемещаться по прямой, если слишком маленькое, курсор будет перемещаться хаотично на экране.
* deviation - Отклонение. Значение плавающей точки, которое устанавливает силу отклонения курсора от линии между начальной и конечной точками. Это можно представить как ветер, который отклоняет курсор от этой линии.
*/
function BAS_default_move_params() {
const speed = _function_argument('speed') || 100
const gravity = _function_argument('gravity') || 6
const deviation = _function_argument('deviation') || 2.5
_default_move_params({
speed: speed,
gravity: gravity,
deviation: deviation
})
}
/**
* Уведомления (async)
* Разрешать или запрещать уведомления.
* В обычном браузере уведомления отображаются на рабочем столе пользователя. Перед тем как начать их получать пользователь должен разрешить уведомления. Вызов этого действия идентичен запрету или разрешению уведомлений в зависимости от значения параметра. скрин1 (https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=allownotifications.png), скрин2 (https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=notificationexample.png).
* По умолчанию уведомления отключены.
* Если вы хотите включать уведомления только для определенных сайтов, используйте это действие несколько раз перед загрузкой каждого сайта.
* Это действие необходимо вызвать до того, как будет загружена любая страница, на которой отображаются уведомления.
* ВАЖНО: уведомления часто используются вместе с сервисами, а они работают только с включенными профилями. Таким образом, вместе с этим действием лучше использовать локальные профили.
* @param enbale Разрешать (true) или запрещать (false) уведомления.
* Примеры:
* true - Всегда разрешать уведомления для всех следующих запросов.
* false - Всегда запрещать уведомления для всех следующих запросов.
* @param callback Функция
*/
function BAS_enable_notifications(enable, callback) {
const enable = _function_argument('enable') || enable
const callback = _function_argument('callback') || (callback || function() {})
_enable_notifications(enable, callback)!
}
/**
* Открыть браузер (async)
* Создать браузер, если он не был создан ранее. Это действие не обязательно использовать для работы с браузером.
* По умолчанию браузер создается только после запуска первого действия, использующего браузер. После того, как браузер создан, он не будет остановлен до конца работы потока ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimedefault.png). Запуск и работа браузера, особенно в многопоточном режиме, является задачей, которая потребляет много ресурсов ПК, поэтому стандартный подход может быть не всегда эффективным. Чтобы избежать использования браузера, когда он вам не нужен, вы можете явно указать время работы браузера с помощью действий 'Открыть браузер' и 'Закрыть браузер', ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimemanual.png).
* Если скрипт содержит хотя бы одно действие 'Открыть браузер' или 'Закрыть браузер', тогда включается режим ручного управления браузером. Это означает, что вы должны явно указать все места, где должен быть создан браузер, и места, где браузер должен быть закрыт. Если вы попытаетесь использовать браузер тогда, когда браузер еще не создан или уже закрыт, поток завершится с ошибкой ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimefail.png).
* Очень важно понять, что по умолчанию браузер создается автоматически, и вам не нужно вызывать действие 'Открыть браузер', если только не требуется контролировать время работы браузера вручную.
*/
function BAS_open_browser() {
open_browser()!
}
/**
* Закрыть браузер
* Закрыть браузер, который был создан с помощью действия 'Открыть браузер'. Это действие не обязательно для работы с браузером.
* По умолчанию браузер создается только после запуска первого действия, использующего браузер. После того, как браузер создан, он не будет остановлен до конца работы потока ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimedefault.png). Запуск и работа браузера, особенно в многопоточном режиме, является задачей, которая потребляет много ресурсов ПК, поэтому стандартный подход может быть не всегда эффективным. Чтобы избежать использования браузера, когда он вам не нужен, вы можете явно указать время работы браузера с помощью действий 'Открыть браузер' и 'Закрыть браузер', ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimemanual.png).
* Если скрипт содержит хотя бы одно действие 'Открыть браузер' или 'Закрыть браузер', тогда включается режим ручного управления браузером. Это означает, что вы должны явно указать все места, где должен быть создан браузер, и места, где браузер должен быть закрыт. Если вы попытаетесь использовать браузер тогда, когда браузер еще не создан или уже закрыт, поток завершится с ошибкой ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=browserlifetimefail.png).
* Очень важно понять, что по умолчанию браузер создается автоматически, и вам не нужно вызывать действие 'Открыть браузер', если только не требуется контролировать время работы браузера вручную.
*/
function BAS_close_browser() {
close_browser()
}
/**
* Код страницы (BAS-функция)
* Получение кода страницы и сохранение его в переменной. Это действие сохраняет текущий код со всеми изменениями, а не тот, который сервер вернул изначально.
* Вы можете парсить его с помощью регулярных выражений или xpath.
* element - элемент html-страницы, с которого получать скрипт
*/
function get_html_script(element) {
const element = _function_argument('element') || element
page().script(element)!
const result = _result()
_function_return(result)
return result
}
/**
* Получить разрешение и положение курсора (BAS-функция)
* Получить текущий размер браузера, положение курсора и прокрутки.
* Чтобы изменить размеры браузера, используйте действие "Разрешение".
* Чтобы изменить текущее положение прокрутки, используйте действие "Прокрутка".
* Чтобы изменить текущее положение курсора, используйте действие "Двигать Мышь".
* Возвращает объект с полями:
* cursorX - Положение курсора X
* cursorY - Положение курсора Y
* scrollX - Положение прокрутки X
* scrollY - Положение прокрутки Y
* width - Ширина браузера
* height - Высота браузера
*/
function get_browser_screen_settings() {
_get_browser_screen_settings()!
const result = JSON.parse(_result())
const obj = {
scrollX: result['ScrollX'],
scrollY: result['ScrollY'],
cursorX: result['CursorX'],
cursorY: result['CursorY'],
width: result['Width'],
height: result['Height'],
}
_function_return(obj)
_result_function()
return obj
}
/**
* Прокси
* По умолчанию браузер работает без прокси, это действие устанавливает его.
* Используйте ресурсы, если вы хотите взять прокси из файла, url или базы данных.
* Вы можете изменить прокси до или после создания браузера или загрузки страницы.
* Пустой параметр сбросит прокси до значения по умолчанию(прямое соединение).
* 'Настройки безопасности' задают различные настройки браузера в соответствии с новым прокси, например: часовой пояс и месторасположение. Эти сделает ваше приложение менее обнаруживаемым. Проверьте информацию для каждого отдельного параметра, чтобы понять, для чего он нужны. Настройки по умолчанию обеспечат оптимальную работу.
* Параметры:
* proxy - Прокси. Строка с информацией о прокси. Она может содержать ip, порт и тип прокси в разных форматах. Эта строка может также содержать логин и пароль, если их нету, данные для аутентификации могут быть заданы с параметрами "Логин прокси" и "Прокси пароль". Примеры: 210.10.10.10:1085, username:password@210.10.10.10:1085, socks5://210.10.10.10:1085, socks:210.10.10.10:1085:username:password, http:username:password:210.10.10.10:1085, \{\{proxy\}\} - Получить из ресурса, Пустая строка - Без прокси
* proxy_type - Тип прокси. Поддерживаются прокси типа socks5 и http. Примеры: socks, socks5 - То же, что и socks; http, https - То же, что и http
* login - Прокси Логи. Может быть пустым. Логин от прокси, переопределяет логин в строке прокси. Полезно, если у вас много прокси с одинаковыми логинами и паролями.
* password - Пароль Прокси. Может быть пустым. Пароль от прокси, переопределяет пароль в строке прокси. Полезно, если у вас много прокси с одинаковыми логинами и паролями.
* settings.changeTimeZone - Изменить часовой пояс. Изменить часовой пояс браузера в соответствии с прокси. Например, если прокси находится в Англии, то часовой пояс браузера будет изменен на UTC+00:00. Вы можете задать произвольное значение с помощью модуля "Часовой пояс". Примеры: true - Изменить часовой пояс, false - Не изменять часовой пояс
* settings.changeLocation - Изменить месторасположение. Изменить месторасположение (координаты) браузера в соответствии с положением прокси. Оно будет установлено в точку, близкую к долготе/широте прокси. Вы можете задать произвольное значение с помощью модуля "Часовой пояс". Примеры: true - Запрос браузера на доступ к вашему месторасположению будет принят. Расположение баузера будет установлено в соответствии с прокси. false - Не менять месторасположение. Запрос браузера на доступ к вашему месторасположению будет отклонен.
* settings.changeIPWebRTC - Изменить ip WebRTC. Заменить ip, возвращаемый WebRTC на ip прокси. Если вы хотите задать произвольное значение, используйте действие "Настройки браузера". Примеры: true - Включить WebRTC, заменить ip, возвращаемый WebRTC на ip прокси. false - Не менять состояние WebRTC.
* settings.changeBrowserLanguage - Изменить язык браузера. Изменить язык браузера в зависимости от страны прокси. Этот параметр изменит заголовок Accept-Language, а также свойства javascript navigator.language и navigator.languages. По умолчанию значение языка будет состоять из языка и кода страны, разделенными дефисом, например 'de-DE' для Германии. Это значение корректное, но большинство браузеров использует более сложные варианты. Если вы хотите, чтобы BAS выглядел как настоящий браузер, используйте сервис FingersprintSwitcher, он установит язык в более естественное значение, например, для iPhone из Германии оно будет ровно 'de,en;q=0.8, *;q=0.01'. Вы также можете установить это значение явно, используя действие "Установить заголовок". Примеры: true - Изменить язык браузера в зависимости от страны прокси. false - Не изменять язык браузера, значение по умолчанию - 'en-US,en;q=0.9'.
* settings.changeExternalIP - Определить внешний ip. Определить ip через внешний сервис. Этот параметр может быть полезен в том случае, если ip, который вы используете для подключения прокси, не соответствует ip видимому сайтом (внешнему ip). BAS будет использовать сервис ip.bablosoft.com для получения значения внешнего ip, а параметры "Изменить часовой пояс", "Изменить месторасположение" и "Изменить ip WebRTC" будут изменены в соответствии с полученным значением ip. Примеры: true - Использовать ip полученный из сервиса. false - Использовать ip полученный из строки прокси.
* info.methodIP - Метод получения информации о IP. Метод, который будет использоваться для получения информации об IP. Примеры: database - Использовать внутреннюю базу данных, данный подход работает быстро и всегда доступен. Хотя база данных постоянно обновляется, этот метод может быть не самым точным по сравнению с другими. ip-api.com - Использовать сервис ip-api.com. Бесплатная версия имеет ограничение - 45 запросов с одного IP. Pro версия не ограничена количеством запросов, но стоит 15$ в месяц. custom function - Использовать отдельную BAS функцию для получения информации.
* info.key - Ключ ip-api.com. Может быть пустым. Ключ от сервиса ip-api.com pro версии. Ключ доступен после покупки. Этот параметр используется только в том случае, если для параметра "Метод получения информации о IP" задано значение "ip-api.com" Примеры: Пустая строка - Использовать бесплатную версию, Ключ - Использовать pro версию
* info.func - Отдельная функция для получения информации об IP. Отдельная функция BAS, которая получает строку IP {входной параметр называется "Ip"} и возвращает JSON с информацией об IP. Этот параметр используется только в том случае, если для параметра "Метод получения информации о IP" задано значение "custom function" Примеры:
* {
*valid: true,
*city: "Frankfurt am Main",
*country: "DE",
*dstoffset: -120,
*offset: -60,
*timezone: "Europe/Berlin",
*longitude: 8.6843,
*latitude: 50.1188,
* } - Пример JSON, который должна возвращать функция.
*/
function BAS_proxy() {
const proxy = _function_argument('proxy')
const proxy_type = _function_argument('proxy_type')
const login = _function_argument('login')
const password = _function_argument('password')
const settings = _function_argument('settings')
const info = _function_argument('info')
const hash = proxy_set_hash(proxy, proxy_type, login, password)
if (_get_profile().length > 0) {
if (hash.server.length === 0) {
native("filesystem", "removefile", _get_profile() + "/proxy.txt")
} else {
const portNumber = hash.Port
hash.Port = hash.Port.toString()
native("filesystem", "writefile", JSON.stringify({path: _get_profile() + "/proxy.txt",value: JSON.stringify(hash),base64:false,append:false}))
hash["Port"] = portNumber
}
}
set_proxy(hash.server, hash.Port, hash.IsHttp, hash.name, hash.password)!
sleep(1000)!
set_proxy_extended(settings.changeTimeZone === "true", settings.changeLocation === "true", settings.changeIPWebRTC === "true", settings.changeBrowserLanguage === "true", settings.changeExternalIP === "true", info.methodIP, info.key, info.func)!
sleep(1000)!
}
/**
* Выполнить javscript в браузере
* Максимальное время выполнения задания - general_timeout_next перед этой функцией
* Выполнить javascript внутри браузера. Это означает, что доступны document, window и другие javascript объекты браузера.
* Действие работает точно так же, как если бы вы вводили код в консоль браузера.
* Вы можете использовать переменные BAS в данном действии как для чтения, так и для записи. Кроме того они могут быть любого типа, в том числе объектами и массивами.
* Переменные используемые в коде автоматически обновляются после выполнения действия.
* Ресурсы не доступны для использования в данном действии.
* Во время выполнения скрипта могут возникать разные ошибки. В случае ошибки BAS прекратит выполнение скрипта.
* Для того чтобы обработать подобные ситуации используйте действие Игнорировать ошибки.
* В таком случае вы сможете использовать переменные VAR_WAS_ERROR и VAR_LAST_ERROR, чтобы узнать, была ли ошибка, и обработать её.
* Пример #1. Изменение HTML определенного элемента:
* document.getElementById("id").innerHTML = VAR_ELEMENT_HTML;
* Пример #2. Получение HTML определенных элементов:
* VAR_ELEMENT1_HTML = document.getElementById("id1").innerHTML;
* VAR_ELEMENT2_HTML = document.getElementById("id2").innerHTML;
* Пример #3. Установка значений для элементов `input` и `textarea`:
* document.querySelector('textarea').value = VAR_TEXTAREA_VALUE.join('\r\n');
* document.querySelector('input').value = VAR_INPUT_VALUE;
* В данном действии вы можете писать код с использованием async и await. Действие будет ожидать завершения асинхронных операций.
* При использовании асинхронного кода всегда дожидайтесь завершения функций с помощью await.
* В противном случае переменные, значение которых задается в коллбэках либо в функциях then/catch/finally у класса Promise, не будут синхронизированы с BAS.
* Если в таких участках кода вам не нужно обновлять переменные, вы можете не ждать их завершения.
* Простой пример. Асинхронное ожидание в течение заданного времени (2 секунды):
* await new Promise((resolve) => { setTimeout(() => resolve(), 2000); });
* Другой пример. Получение данных со стороннего сайта с помощью функции fetch:
* async function getPost(id) {
*return await fetch(`https://jsonplaceholder.typicode.com/posts/` + id)
*.then((res) => res.json());
* }
* VAR_POST = await getPost(1);
*/
function BAS_javascript(script) {
const script = _function_argument('script') || script
page().script2(script,JSON.stringify(_read_variables([])))!
const _parse_result = JSON.parse(_result())
_write_variables(JSON.parse(_parse_result.variables))
if(!_parse_result.is_success)
fail(_parse_result.error)
}
/**
* Выполнять при каждой загрузке страницы в браузере
* Это действие задает скрипт, который должен выполняться на каждой странице и в каждом фрейме сразу после создания страницы. В отличие от действия "Яваскрипт", скрипт, определенный здесь, выполняется в самом начале загрузки страницы, что дает возможность изменять внутренние элементы браузера, такие как window.navigator. Действие должно быть выполнено до загрузки страницы.
* script - Текст сценария
* url - Применять к урл. Измените этот параметр, если вы хотите применить действие только к определенным url. * означет любое количество любых символов. Вы можете использовать несколько действий с разными параметрами "Применять к урл". Например, установите один прокси-сервер для *instagram.com* адресов и другой для *google.com* адресов. Или установите один прокси для *instagram.com* адресов и другой для всех остальных с помощью *
* Примеры: * - Любой url; *google.com* - Любой адрес, который содержит google.com
* tab - Применять к вкладке с номером. Измените этот параметр, если вы хотите применить действие только к определенным влкадкам. * означает применить к любым вкладкам. Вы можете использовать несколько действий с разными параметрами "Применять к вкладке с номером". Например, установите один прокси-сервер для 0 вкладки и другой для 1 вкладки. Или установите один прокси для 0 вкладки и другой для всех остальных с помощью *
* Примеры: * - Любая вкладка; 0 - Только первая вкладка
*/
function BAS_onLoadJavascript(script, url, tab) {
const script = _function_argument('script') || script
const url = _function_argument('url') || url
const tab = _function_argument('tab') || tab
_set_target({
url: url,
tab: tab,
})
onloadjavascript(script)!
}
/**
* Скриншот (async)
* Это действие делает скриншот выбранной части экрана и сохраняет его в изображении в формате png, закодированном как строка base64.
* Если выбранная область не видна, страница будет прокручена.
* Координаты X и Y задаются в абсолютном смещении от краев страницы.
* Если вы хотите сделать скриншот определенного элемента, нажмите на него и выберите действие "Скриншот".
* Если вы хотите сделать снимок всей страницы, нажмите на любой элемент в браузере и используйте действие "Скриншот" с селектором >CSS> body.
* @param x X
* @param y Y
* @param width Ширина
* @param height Высота
* @param callback функция
*/
function BAS_render(x, y, width, height) {
const x = _function_argument('x') || x
const y = _function_argument('y') || y
const width = _function_argument('width') || width
const height = _function_argument('height') || height
render(x, y, width, height)!
const result = _result()
_function_return(result)
return result
}
/**
* Решить Капчу (BAS-функция)
* Это действие решает капчу в виде картинки(не recaptcha) и работает, только если у вас есть данные изображения, отформатированного как строка в формате base64.
* Текст капчи сохраняется в переменной и может быть использован позже.
* Если вы хотите решить капчу из элемента на экране, вы должны нажать на него и используйте действие "Решить Капчу".
* Если вы хотите решить recaptcha, нажмите на флажок recaptcha внутри браузера и выберите "Решить Recaptcha 2.0".
* @param {string} dataBase64 Данные изображения в base64. Данные в формате base64, их можно получить из действия скриншот или из действия читать файл.
* @param {string} method Метод решения. Метод решения - это строка, вы можете установить значение напрямую или использовать переменную или ресурс. Примеры:
* manual - Капча решается вручную человеком, который использует БАС.
* antigate - Решить с помощью сервиса http://anti-captcha.com/
* rucaptcha - Решить с помощью сервиса http://rucaptcha.com/
* 2captcha - Решить с помощью сервиса http://2captcha.com/
* capmonster - Решить с помощью capmonster
* dbc - Решить с помощью сервиса http://deathbycaptcha.com/
* @param {string} key Ключ Антигейт/Рукапча/2капча/dbc. Может быть пустым. Этот ключ необходим только в том случае, если вы спользуете сервисы для решения капчи. Он не нужен в режимах manual, capmonster и captchasniper. В случае deathbycaptcha это поле должно содержать dbc_login:dbc_password.
* @param {string} serverUrl Url сервера. Может быть пустым. Примеры:
* http://127.0.0.3:8083/
* Пустая строка - Использовать url по умолчанию, например, http://rucaptcha.com для rucaptcha.
* @return Строка с результатом решения капчи
*/
function BAS_solveCaptcha() {
const dataBase64 = _function_argument('dataBase64')
const method = _function_argument('method')
const key = _function_argument('key')
const serverUrl = _function_argument('serverUrl')
solver_properties_clear(method)
BAS_SolveRecaptcha_Serverurl = serverUrl;
if (BAS_SolveRecaptcha_Serverurl.length > 0 && BAS_SolveRecaptcha_Serverurl.substr(BAS_SolveRecaptcha_Serverurl.length - 1) != "/") BAS_SolveRecaptcha_Serverurl += "/"
if(method === "rucaptcha") {
if(BAS_SolveRecaptcha_Serverurl) solver_property("rucaptcha","serverurl",BAS_SolveRecaptcha_Serverurl)
rucaptcha(key)
}
if(method === "antigate") {
if(BAS_SolveRecaptcha_Serverurl) solver_property("antigate","serverurl",BAS_SolveRecaptcha_Serverurl)
antigate(key)
}
if(method === "dbc") {
if(BAS_SolveRecaptcha_Serverurl) solver_property("dbc","serverurl",BAS_SolveRecaptcha_Serverurl)
dbc(key)
}
if(method === "2captcha") {
if(BAS_SolveRecaptcha_Serverurl) solver_property("2captcha","serverurl",BAS_SolveRecaptcha_Serverurl)
twocaptcha(key)
}
if(method === "capmonster" || method === "capmonsterimage" || method === "capmonsteraudio") {
solver_property("capmonster","serverurl",BAS_SolveRecaptcha_Serverurl)
capmonster(key)
}
_if_else(method == "captchasniper", function(){
_switch_http_client_internal()
http_client_post(BAS_SolveRecaptcha_Serverurl, ["file","base64://" + dataBase64], {"content-type":("multipart"), "encoding":("UTF-8"), "method":("POST")})!
{const split = http_client_content().split("|");VAR_CAPTCHA_RESULT = split[split.length-1]}
_switch_http_client_main()
}, function(){
solve_base64("manual",dataBase64)!
VAR_CAPTCHA_RESULT = _result()
})!
_function_return(VAR_CAPTCHA_RESULT)
}
/**
* Решить капчу кликами (BAS-функция, вызов через _call_function)
* Решить любой тип капчи, который требует кликать по изображениям.
* Для решения ReCaptcha и HCaptcha рекомендуется использовать действия Решить Recaptcha 2.0 и Решить HCaptcha из контекстного меню браузера, если это возможно. С ними проще работать, и капча может решиться быстрее. Также эти действия позволяют выполнять автоматическую валидацию решения. Используйте это действие, если другие варианты не подходят вам по каким-либо причинам.
* Это действие позволяет вам решить любую капчу, которая требует, чтобы вы нажимали на изображения в соответствии с определенными инструкциями. Это может быть ReCaptcha, HCaptcha и другие типы. Для решения таких капч необходимо отправить на сервис изображение, содержащее элементы, по которым нужно выполнить клики. Если на капче или рядом с ней присутствует описание, рекомендуется отправлять его вместе с изображением, чтобы избежать неверных решений.
* Данное действие не выполняет автоматических кликов по координатам, в отличие от действия Решить капчу кликами из контекстного меню браузера, которое делает всё без вашего участия. Использовать его будет намного проще.
* После того, как сервис решит капчу, вы получите список координат, по которым необходимо будет выполнить клики. Для того, чтобы выполнить клики, данный список необходимо пройти любым циклом, например for или foreach, и на каждой итерации вызвать действие Кликнуть для каждой пары координат X и Y. После выполнения кликов вам необходимо вручную продолжить работу. То есть, вы должны сами выполнить подтверждение решения или перейти к следующему изображению.
* Для всех сервисов требуется сервисный ключ, который должен быть получен на сайте сервиса и введён в поле Ключ сервиса.
* Для выполнения кликов по полученным координатам вам нужно учитывать позицию элемента, скриншот которого вы отправляете, относительно страницы, а также скролл по вертикали и горизонтали. Поэтому самым простым вариантом будет использование аналогичного действия для конкретного элемента из контекстного меню браузера, где клики будут выполняться автоматически.
* Важный момент - данное действие не выполняет автоматического подтверждения решения капчи. Вы должны сделать это сами. Например, если вы решаете ReCaptcha2 используя данный метод, то вам нужно самостоятельно выполнить клик по чекбоксу, а после выполнения кликов по координатам - нажать на кнопку Далее или Готово.
* Параметр Интервал проверки решения задачи отвечает за частоту отправки запросов на сервис для проверки решения капчи. Чем больше вы выставите значение, тем дольше BAS будет ожидать перед тем, как отправить очередной запрос. Рекомендуется использовать задержку не менее 5 секунд.
* Параметр Задержка проверки решения задачи отвечает за длительность ожидания перед тем, как BAS начнет проверку капчи. Сначала капча отправляется на сервис, после этого BAS будет ожидать указанное время, по прошествии которого начнется непосредственно проверка состояния задачи. Большинство сервисов рекомендуют подождать не менее 5 секунд.
* Если нужного сервиса нет в списке доступных, но он работает через API аналогичный выбранному сервису, вы можете указать необходимый URL сервера в поле URL сервиса, находящееся в дополнительных настройках.
* Если вы используете такие программы, как CapMonster, XEvil или аналоги, вы должны заполнить поле URL сервиса в соответствии с документацией к данному ПО.
* Подробную документацию по решению подобных капч можно посмотреть здесь. https://rucaptcha.com/api-rucaptcha#solving_clickcaptcha
* Второй аргумент - объект с параметрами:
*
* textInstructions - Описание капчи. Может быть пустым. Если у captcha есть какое-либо описание, его можно добавить в это поле.
* Примеры:
* Выберите все изображения, на которых есть самолёт
* Выберите все изображения, на которых есть лодка
*
* dataBase64 - Данные изображения в base64. Данные в формате base64, их можно получить из действия скриншот или из действия читать файл.
*
* taskWaitTimeout - Интервал проверки решения задачи в миллисекундах. С помощью этого параметра вы можете контролировать длительность паузы между каждой новой проверкой решения капчи.
* Примеры:
* 600 - Ждать в течение 600 миллисекунд
* 10000 - Ждать в течение 10 секунд
* 5000 - Ждать в течение 5 секунд
*
* taskWaitDelay - Задержка проверки решения задачи в миллисекундах. С помощью этого параметра вы можете контролировать длительность паузы между отправкой капчи на сервис и началом ожидания решения. Чаще всего, сервисы решения капчи указывают необходимое время ожидания, в остальных случаях вы можете указать любое удобное для вас значение.
* Примеры:
* 600 - Ждать в течение 600 миллисекунд
* 10000 - Ждать в течение 10 секунд
* 5000 - Ждать в течение 5 секунд
*
* serviceName - Название сервиса для решения капчи
* Примеры:
* rucaptcha - Решить капчу используя сервис https://rucaptcha.com/
* 2captcha - Решить капчу используя сервис https://2captcha.com/
*
* serviceUrl - URL сервиса. Может быть пустым. ВЫ можете использовать этот параметр, если нужного вам сервиса нет в списке доступных. В таком случае укажите название сервиса, котрый работает по аналогичному API, и используйте нужный вам адрес.
* Примеры:
* Пустая строка - Использовать стандартный URL сервиса, http://rucaptcha.com для RuCaptcha и так далее
* http://127.0.0.1:8083 - Использовать кастомный URL сервиса с портом 8083
* http://127.0.0.3:8080 - Использовать кастомный URL сервиса с портом 8080
*
* serviceKey - Ключ сервиса. Ключ от сервиса решения капчи. Вы можете получить его в личном кабинете выбранного сервиса решения капчи
*
* imageData - Данные изображения в base64. Их можно получить из действия скриншот или из действия читать файл.
*/
function BAS_solve_coordinates_captcha() {
const args = _arguments()
_call_function(BASCaptchaSolver.solveCoordinatesCaptcha, {
textInstructions: args.textInstructions || "",
taskWaitTimeout: args.taskWaitTimeout || 0,
taskWaitDelay: args.taskWaitDelay || 0,
serviceName: args.serviceName || "rucaptcha",
serviceUrl: args.serviceUrl || "",
serviceKey: args.serviceKey || "",
imageData: args.imageData || "",
})!
}
/**
* Настройки Браузера (BAS-функция)
* Изменяет настройки браузера: работа с сетью, canvas, webgl и другое. Используйте действие "Получить отпечаток" чтобы поменять отпечаток браузера.
* Пустая строка или 0 означает, что значение изменяться не будут.
* Смена параметров "Флеш", "Расширения", "Widevine" или "Командная строка" перезапустит браузер и таким образом обнулят остальные настройки(прокси, заголовки, и т.д.), так что лучшее место для этого действия - начало работы потока.
* Расширение Chrome можно использовать в BAS, введя либо id расширения, либо url расширения, либо путь к расширению в поле "Расширения:". Id расширения - это уникальная строка длиной 32, например padekgcemlokbadohgkifijomclgjgif. Url расширения - это основной адрес расширения в магазине Chrome. Его домен - chrome.google.com, например: https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif. Путь расширения - это путь к распакованным файлым расширения. Каждый путь должен содержать папку с manifest.json и другими файлами. Смотрите эту ссылку, для инструкций касающихся распаковки расширений и другой информации об их использовании.
* Чтобы включить флеш, вам нужно помимо изменения настройки "Флеш" в этом действии также установить флеш на ваш ПК. Инстукция расположена здесь https://wiki.bablosoft.com/doku.php?id=how_to_enable_flash.
* Если вы хотите поменять настройки для всех потоков, то лучше воспользоваться вкладкой настройки.
*
*
* Параметры:
*
* @param {string} flash enable | disable | ''
* Использование флеш может раскрыть ваш ip, поэтому включать его не рекомендуется. Если вы все же хотите включить флеш, измените эту настройку и установите его на вашем ПК, инструкции находятся в блоке ниже.
* Примеры:
* enable - Использовать flash
* disable - Не использовать flash
* Пустая строка - Не изменять эту настройку
*
* @param {string} widevine enable | disable | ''
* Включить или отключить плагин Widevine.
* Примеры:
* enable - Использовать Widevine
* disable - Не использовать Widevine
* Пустая строка - Не изменять эту настройку
*
* @param {string} webRTC enable | disable | replace | ''
* Использование WebRTC также может раскрыть ваш ip даже если вы используете прокси.
* Примеры:
* enable - Включить WebRTC
* disable - Отключить WebRTC
* replace - Заменить ip, возвращаемые WebRTC значениями из поля 'WebRTC список ip'.
* Пустая строка - Не изменять эту настройку
*
* @param {string} webRTCIps
* Заменить ip, возвращаемые WebRTC значениями из этого поля. Эта настройка работает только если параметр 'WebRTC' установлен в значение 'replace'. Каждая строка этого поля должна содержать один ip. Этот параметр предназначен только для целей отладки, правильный способ изменения WebRTC ip - использовать действие 'Прокси'.
* Примеры:
* 192.168.0.1 - Локальный адрес
* 142.1.2.3 - Внешний адрес
* Clear - Удалить все ip
* Пустая строка - Не изменять
*
* @param {string} canvas enable | disable | noise | ''
* Это html элемент, который содержит графику: разнообразные фигуры, изображения, текст и т.д. Разные браузеры и операционные системы рисуют эти элементы немного по-разному. Сайт может использовать эти отличия, чтобы идентифицировать вас среди других пользователей. BAS позволяет защитить вас отключая canvas-элемент полностью или добавляя шум к получаемому изображению.
* Примеры:
* enable - Использовать canvas
* disable - Не использовать canvas
* noise - Добавить шум к изображению canvas.
* Только для целей отладки, используйте сервис FingersprintSwitcher, чтобы задать шум.
* Пустая строка - Не изменять эту настройку.
*
* @param {stirng} canvasNoise Шаблон шума canvas. Эта настройка находится здесь только для целей отладки, правильный метод добавления шума - использования сервиса FingersprintSwitcher
*
* @param {string} webGL enable | disable | noise | ''
* Также как и canvas позволяет идентифицировать вас среди других пользователей.
* Примеры:
* enable - Исопльзовать WebGL
* disable - Не использовать WebGL
* noise - Добавить шум к изображению WebGL.
* Только для целей отладки, используйте сервис FingersprintSwitcher, чтобы задать шум.
* Пустая строка - Не изменять эту настройку
*
* @param {string} webGLNoise Шаблон шума WebGL. Эта настройка находится здесь только для целей отладки, правильный метод добавления шума - использование сервиса FingersprintSwitcher
*
* @param {string} webGLVendor Через свойство WebGL vendor сайт может узнать характеристики вашего оборудования через javascript, так что имеет смысл менять это значение. Пустое поле оставит реальное значение. Эта настройка находится здесь только для целей отладки, правильный метод добавления шума - использование сервиса FingersprintSwitcher
* Примеры:
* Google Inc. - Пример поля из реального браузера
* Пустая строка - Не изменять эту настройку
*
* @param {string} webGLRenderer Через свойство WebGL renderer сайт может узнать характеристики вашего оборудования через javascript, так что имеет смысл менять это значение. Пустое поле оставит реальное значение. Эта настройка находится здесь только для целей отладки, правильный метод добавления шума - использование сервиса FingersprintSwitcher
* Примеры:
* Google Inc. - ANGLE (NVIDIA GeForce GTX 550 Ti DIrect3D11 vs_5_0 ps_5_0)
* Пустая строка - Не изменять эту настройку
*
* @param {string} audio enable | disable | noise | ''
* Сайт может идентифицировать пользователя, генерируя звук и считывая его как массив данных. Различные браузеры и операционные системы будут выполнять эту операцию с немного разными результатами. BAS позволяет защитить вас, запретив браузеру получать звуковые данные или добавляя шум к этим данным.
* Примеры:
* enable - Включить audio api
* disable - Отключить методы audio api, используемые для получения отпечатков
* noise - Добавить шум к получаемому звуку. Только для целей отладки, используйте сервис FingersprintSwitcher, чтобы задать шум.
* Пустая строка - Не изменять эту настройку
*
* @param {string} audioNoise Шаблон шума audio. Эта настройка находится здесь только для целей отладки, правильный метод добавления шума - использование сервиса FingersprintSwitcher
*
* @param {string} QUIC enable | disable | ''
* Включить протокол QUIC. В отличие от HTTP, протокол QUIC построен поверх UDP. Не все прокси поддерживают UDP. Это означает, что включение QUIC может вызвать проблемы при работе с определенными прокси. Рекомендуется включать эту опцию только в том случае, если вы уверены, что прокси ее поддерживает. ПО умолчанию отключено.
* Примеры:
* enable - Включить QUIC
* disable - Отключить QUIC
* Пустая строка - Не изменять эту настройку
*
* @param {number} maxFPS Ограничения частоты кадров
* Максимальное количество раз за одну секунду, которое содержимого браузера может быть отрисовано. Чем ниже это значение, тем меньше будет нагрузка на процессор.
* Установка слишком низкого значения может повлиять на работоспособность сайта. Снижение его ниже 30 может привести к непредсказуемым последствиям. Минимальное значение 10.
* Примеры:
* 30 - Ограничить частоту кадров 30
* 0 - Не менять частоту кадров
*
* @param {string} extensions Каждая строка должна содержать либо путь к файлу, либо id расширения, либо url расширения, примеры: с:/путь/к/расширению/ http://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif padekgdemlokbadohgkifijomclgjgif
* Расширение Chrome можно использовать в BAS, введя в это поле либо id расширения, либо url расширения, либо путь к расширению. Самый простой способ начать использовать расширение - скопировать url из магазина Chrome в это поле.
* Примеры:
* http://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif - Загрузить расширение по url
* padekgdemlokbadohgkifijomclgjgif - Загрузить расширение по id
* c:/extensions/background - Загрузить расширение из заданной папки. Файл c:/extensions/background/manifest.json обязательно должен существовать
* Clear - Убрать все расширения
* Пустая строка - Не изменять
*
* @param {string} commandLines Каждая строка должна содержать один параметр командной строки, который будет использоваться для запуска браузера. Это может быть как отлько один ключ так и ключ вместе со значением, Примеры: --disable-component-update --lang=ru-RU
* Это поле может содержать дополнительные параметры командной строки, используемые для запуска браузера. Их также можно указать, изменив файл chrome_command_line.txt внутри папки apps/BASVERSION. Если в обоих местах будет указан один и тот же ключ, предпочтение будет отдано этому полю. Предыдущий список параметров командной строки будет заменен этим значением.
* Примеры:
* --key - Отправить только ключ
* --key=value - Отправить ключ со значением
* Clear - Удалить все параметры командной строки
* Пустая строка - Не изменять
*/
function BAS_settings() {
const args = _arguments()
const Params = {}
const flash = args.flash || ""
const widevine = args.widevine || ""
const param_extensions = args.extensions || ""
_require_extensions(param_extensions)!
const extensions = (_result())
const commandLines = args.commandLines || ""
const webRTC = args.webRTC || ""
const webRTCIps = (args.webRTCIps || "").split(/\r?\n/).filter(function(x) {
return x && x.length > 0
}).map(function(x) {
return x.replace(/\s/g, '')
}).join(';')
const canvas = args.canvas || ""
const canvasNoise = args.canvasNoise || ""
const audio = args.audio || ""
const audioNoise = args.audioNoise || ""
const QUIC = args.QUIC || ""
const maxFPS = args.maxFPS || 0
const webGL = args.webGL || ""
const webGLNoise = args.webGLNoise || ""
const webGLVendor = args.webGLVendor || ""
const webGLRenderer = args.webGLRenderer || ""
if (flash.length > 0) Params.UseFlash = flash === 'enable'
if (widevine.length > 0) Params.UseWidevine = widevine === 'enable'
if (webRTC.length > 0) Params.Webrtc = webRTC
if (canvas.length > 0) Params.Canvas = canvas
if (canvasNoise.length > 0) Params.CanvasNoise = canvasNoise
if (audio.length > 0) Params.Audio = audio
if (audioNoise.length > 0) Params.AudioNoise = audioNoise
if (QUIC.length > 0) Params.QUIC = QUIC
if (maxFPS > 0) Params.MaxFPS = maxFPS
if (webGL.length > 0) Params.Webgl = webGL
if (webGLNoise.length > 0) Params.WebglNoise = webGLNoise
if (webGLVendor.length > 0) Params.Webgl.unmaskedVendor = webGLVendor
if (webGLRenderer.length > 0) Params.Webgl.unmaskedRenderer = webGLRenderer
if (extensions.length > 0) Params.Extensions = extensions
if (extensions === 'Clear') Params.Extensions = ''
if (commandLines.length > 0) Params.CommandLine = commandLines
if (commandLines === 'Clear') Params.CommandLine = ''
if (webRTCIps.length > 0) Params.WebrtcIps = webRTCIps
if (webRTCIps === 'Clear') Params.WebrtcIps = ''
_settings(Params)!
}
