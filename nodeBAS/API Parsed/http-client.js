/**
* HTTP-Клиент Прокси
* По умолчанию клиент http работает без прокси, это действие устанавливает прокси.
* Используйте ресурсы, если вы хотите взять прокси из файла, url или базы данных.
* Вы можете изменить прокси один раз, и он будет применяться к каждому следующему действию, которое использует http клиент.
* Пустой параметр сбросит прокси до значения по умолчанию(прямое соединение).
* @param {string} proxy Прокси
Строка, c информацией о прокси. Она может содержать ip, порт и тип прокси в разных форматах. Эта строка может также содержать логин и пароль, если их нету, данные для аутентификации могут быть заданы с параметрами "Логин прокси" и "Прокси пароль".
Примеры :
210.10.10.10:1085
username:password@210.10.10.10:1085
socks5://210.10.10.10:1085
socks:210.10.10.10:1085:username:password
http:username:password:210.10.10.10:1085
\{\{proxy\}\} - Получить из ресурса
Пустая строка - Без прокси
* @param {string} proxy_type Тип Прокси
Тип прокси
Поддерживаются прокси типа socks5 и http.
Примеры :
socks
socks5 - То же, что и socks
http
https - То же, что и http
* @param {string} login
Прокси Логин. Может быть пустым.
Логин от прокси, переопределяет логин в строке прокси. Полезно, если у вас много прокси с одинаковыми логинами и паролями.
* @param {string} password
Пароль Прокси. Может быть пустым.
Пароль от прокси, переопределяет пароль в строке прокси. Полезно, если у вас много прокси с одинаковыми логинами и паролями.
*/
function BAS_http_client_set_proxy(proxy, proxy_type, login, password) {
const args = _arguments()
const proxy = args.proxy || (proxy || "")
const proxy_type = args.proxy_type || (proxy_type || "http")
const login = args.login || (login || "")
const password = args.password || (password || "")
const hash = proxy_set_hash(proxy, proxy_type, login, password)
_switch_http_client_main()
http_client_set_proxy(
hash.server,
hash.Port,
hash.IsHttp,
hash.name,
hash.password
)
}
/**
* HTTP-Клиент Сброс
* Это действие перезапустит http клиент и сбросит все его настройки.
* Используйте действие 'HTTP-Клиент Загрузить cookies' с пустым значением, если вы хотите сбросить только файлы cookies.
* Это действие влияет на состояние http клиента и все настройки, такие как: прокси, заголовки, текст последнего ответа от сервера, статус ответа, cookies и т. д.
*/
function BAS_http_client_reset() {
_switch_http_client_main()
new_http_client()
}
/**
* Get запрос (BAS-функция)
* Сделать http-запрос, используя метод GET, HEAD, DELETE, TRACE или OPTIONS,то есть методы, которые не отправляют данные.
* Специальные и нелатинские символы должны быть закодированы с помощью функции encodeURIComponent. Например, вместо использования https://www.google.com/search?q=коты URL должен быть https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B
* Если включен режим 'Захват HTTP-запросов', то каждый запрос, который выполняет браузер, будет преобразован в действия с помощью http-клиента и добавлен во вкладку сценария ( screen ).
* HTTP заголовки (например, User-Agent) могут быть указаны в параметре 'Заголовки' или с помощью действия 'HTTP-Клиент Установить Заголовок'. В первом случае заголовки будут изменены только для текущего действия, во втором случае заголовки будут изменены для всех следующих действий.
* По умолчанию http клиент будет следовать переадресациям. Если вы хотите, вы можете отключить эту настройку и обработывать заголовок 'Location' самостоятельно. Чтобы получить заголовки, которые сервер отсылает в ответ, используйте действие 'Получить заголовок' после запроса.
* Действие 'Get' не возвращает результат через изменение переменных, чтобы получить ответ, вам нужно вызвать действие 'Текущий Url', 'Содержание ответа', 'Статус ответа' или 'Получить заголовок' после выполнения запроса.
* 'Текущий Url' получит последний url после всех перенаправлений.
* 'Содержание ответа' вернет код html последнего запроса.
* 'Статус ответа' возвращает HTTP статус, например, 200 - если запрос выполнен правильно, 500 - в случае ошибки сервера и т. д.
* 'Получить заголовок' возвращает заголовки ответа, например 'Content-Type', 'Date', 'Set-Cookie'
* HTTP клиент обрабатывает cookies автоматически, поэтому вам не нужно обрабатывать заголовок 'Set-Cookie' самостоятельно.
* Самый быстрый способ извлечь данные из кода страницы - xpath. http клиент имеет множество действий для выполнения xpath запросов. Не рекомендуется использовать действие 'Содержание ответа' и регулярные выражения, если только это не абсолютно необходимо.
* Если сервер возвращает данные в формате json, используйте функцию JSON.parse для парсинга.
* Вы можете установить максимальное время загрузки страницы, щелкнув на значок песочных часов возле кнопки 'Отмена'.
* @param {string} url
Url
Url запроса
Примеры :
https://google.com - Url с протоколом
google.com - Url без протокола
https://www.google.com/search?q=cats - Url со строкой запроса
https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B - Url с запросом в формате urlencode. Для кодирования строки используется функция encodeURIComponent.
* @param {string} headers Заголовки, например:
* User-Agent: Mozilla/5.0 Gecko/20100101 Firefox/57.0
* Referer: google.com
* @param {string} method Метод
Метод http запроса, вы можете поместить сюда любую строку.
* @param {boolean} no_redirect Следовать переадресациям
* @param {number} timeout Максимальное время выполнения задания
*/
function BAS_http_client_get() {
const args = _arguments()
_switch_http_client_main()
if (args.timeout) {
general_timeout_next(args.timeout)
}
const obj = {
method: args.method,
headers: args.headers
}
if (no_redirect) {
http_client_get_no_redirect2(args.url, obj)!
} else {
http_client_get2(args.url, obj)!
}
}
/**
* Post запрос (BAS-функция)
* Сделать http-запрос, используя метод POST, PUT или PATCH, то есть любые методы, которые отправляют данные.
* Данные запроса могут быть указаны в двух форматах: в неформатированном и созданных с конструктором. Рекомендуется использовать вариант именно с неформатированными данными.
* При использовании данных запроса в неформатированном виде, вы можете копировать их прямо из http сниффера и помещать в поле никак не изменяя. Проверьте справку для этого поля, она содержит много примеров. Также вам нужно правильно выбрать параметр 'Content-Type', он указывает, какой тип содержимого находится в поле 'Post Data', это может быть json, поля формы на сайте и т. д.
* В поле 'Post Data' могут быть использованы переменные и ресурсы. Если вам нужно отправить двоичные данные, поместите их в переменную с кодировкой base64 (например, прочитав файл в base64) и перед названием переменной поставьте префикс 'base64:'(например, base64:VAR_FILE_CONTENT). В справке к полю 'Post data' содержится больше примеров.
* Если включен режим 'Захват HTTP-запросов', то каждый запрос, который выполняет браузер, будет преобразован в действия с помощью http-клиента и добавлен во вкладку сценария ( screen ). Это самый простой способ сгенерировать действия с использованием http клиента.
* Специальные и нелатинские символы должны быть закодированы с помощью функции encodeURIComponent. Например, вместо использования https://www.google.com/search?q=коты URL должен быть https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B
* HTTP заголовки (например, User-Agent) могут быть указаны в параметре 'Заголовки' или с помощью действия 'HTTP-Клиент Установить Заголовок'. В первом случае заголовки будут изменены только для текущего действия, во втором случае заголовки будут изменены для всех следующих действий.
* По умолчанию http клиент будет следовать переадресациям. Если вы хотите, вы можете отключить эту настройку и обработывать заголовок 'Location' самостоятельно. Чтобы получить заголовки, которые сервер отсылает в ответ, используйте действие 'Получить заголовок' после запроса.
* Действие 'Post запрос' не возвращает результат через изменение переменных, чтобы получить ответ, вам нужно вызвать действие 'Текущий Url', 'Содержание ответа', 'Статус ответа' или 'Получить заголовок' после выполнения запроса.
* 'Текущий Url' получит последний url после всех перенаправлений.
* 'Содержание ответа' вернет код html последнего запроса.
* 'Статус ответа' возвращает HTTP статус, например, 200 - если запрос выполнен правильно, 500 - в случае ошибки сервера и т. д.
* 'Получить заголовок' возвращает заголовки ответа, например 'Content-Type', 'Date', 'Set-Cookie'
* HTTP клиент обрабатывает cookies автоматически, поэтому вам не нужно обрабатывать заголовок 'Set-Cookie' самостоятельно.
* Самый быстрый способ извлечь данные из кода страницы - xpath. http клиент имеет множество действий для выполнения xpath запросов. Не рекомендуется использовать действие 'Содержание ответа' и регулярные выражения, если только это не абсолютно необходимо.
* Если сервер возвращает данные в формате json, используйте функцию JSON.parse для парсинга.
* Вы можете установить максимальное время загрузки страницы, щелкнув на значок песочных часов возле кнопки 'Отмена'.
* @param {string} url
Url
Url запроса
Примеры :
https://google.com - Url с протоколом
google.com - Url без протокола
https://www.google.com/search?q=cats - Url со строкой запроса
https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B - Url с запросом в формате urlencode. Для кодирования строки используется функция encodeURIComponent.
* @param {string} headers Заголовки, например:
* User-Agent: Mozilla/5.0 Gecko/20100101 Firefox/57.0
* Referer: google.com
* @param {string} data Post data
* @param {string} content_type
Content-Type
Заголовок 'Content-Type'. Этот параметр указывает, какой тип содержимого находится в поле 'Post Data'.
Примеры :
application/x-www-form-urlencoded - Данные содержат пары ключ/значение, разделенные символом & (амперсанд). Например, key1=value1&key2=value2&key3=value3
multipart/form-data - Данные содержат пары ключ/значение, значения могут иметь двоичный формат, могут использоваться для отправки файлов. Разделитель между парами ключ/значение будет получен из поля 'Post Data'.
application/json - Отправлять данные в формате json. Например, {"key1": "value1", "key2": "value2", "key3": "value3"}
* @param {string} encoding
Кодировка
Кодировка поля 'Post Data'. Этот параметр задает название кодировки, которая будет использоваться при отправке данных запроса. Он не изменяет заголовок Content-Type, если это требуется, вы должны сделать это самостоятельно.
Примеры :
UTF-8 - Это значение подходит для большинства сайтов.
WINDOWS-1251 - Используется на некоторых российских сайтах.
* @param {string} method
Метод
Метод http запроса, вы можете поместить сюда любую строку.
* @param {boolean} no_redirect Следовать переадресациям
* @param {number} timeout Максимальное время выполнения задания
*/
function BAS_http_client_post() {
const args = _arguments()
_switch_http_client_main()
if (args.timeout) {
general_timeout_next(args.timeout)
}
const obj = {
content_type: 'custom/' + args.content_type,
encoding: args.encoding,
method: args.method,
headers: args.headers
}
if (!args.no_redirect) {
http_client_post(args.url, ['data', args.data], obj)!
} else {
http_client_post_no_redirect(args.url, ['data', args.data], obj)!
}
}
/**
* Скачать (BAS-функция)
* Загрузить выбранный url в файл.
* Если вы не хотите сохранять данные на диске, вы должны использовать действие 'GET' или 'POST'.
* Это действие использует cookies и заголовки, точно так же, как и действия 'GET' и 'POST'.
* Специальные и нелатинские символы должны быть закодированы с помощью функции encodeURIComponent. Например, вместо использования https://www.google.com/search?q=коты URL должен быть https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B
* HTTP заголовки(например, User-Agent) могут быть заданы с помощью действия 'HTTP-Клиент Установить Заголовок'.
* Действие 'Скачать' не возвращает результат через изменение переменных, чтобы получить результат, вам нужно вызвать действие 'Текущий Url', 'Статус ответа' или 'Получить заголовок' после выполнения запроса. И, конечно, указанный файл будет содержать текст ответа.
* 'Текущий Url' получит последний url после всех перенаправлений.
* 'Статус ответа' возвращает HTTP статус, например, 200 - если запрос выполнен правильно, 500 - в случае ошибки сервера и т. д.
* 'Получить заголовок' возвращает заголовки ответа, например 'Content-Type', 'Date', 'Set-Cookie'
* Вы можете установить максимальное время загрузки страницы, щелкнув на значок песочных часов возле кнопки 'Отмена'.
* @param {string} url
Url
Url запроса
Примеры :
https://google.com - Url с протоколом
google.com - Url без протокола
https://www.google.com/search?q=cats - Url со строкой запроса
https://www.google.com/search?q=%D0%BA%D0%BE%D1%82%D1%8B - Url с запросом в формате urlencode. Для кодирования строки используется функция encodeURIComponent.
* @param {string} filepath
Путь к файлу
Путь к файлу, который будет загружен. Если файл существует, он будет перезаписан. Использование ресурса с типом 'LinesFromFile' в этом поле почти всегда приведет к неправильному результату, потому что ресурс будет преобразован в строку из выбранного файла, а не в имя файла. Если вы хотите получить имя файла из ресурса, используйте действие 'Расположение Ресурса' чтобы получить путь к файлу в виде переменной, а уже эту переменную поместите сюда.
Примеры :
c:/downloads/pic.png
c:\downloads\pic.png
* @param {number} timeout Максимальное время выполнения задания
*/
function BAS_http_client_download() {
const args = _arguments()
_switch_http_client_main()
if (args.timeout) {
general_timeout_next(args.timeout)
}
http_client_download(args.url, args.filepath)!
}
/**
* Текущий Url
* Получить текущий url для клиента http.
* Url может отличаться от последнего url, используемого в действии 'GET' или 'POST', если были перенаправления.
* @returns текущий url для http-клиента
*/
function BAS_http_client_url() {
_switch_http_client_main()
return http_client_url()
}
/**
* Содержание ответа
* Получить код страницы для последнего запроса http клиента.
* Код страницы, который возвращает это действие точно такой же, как и тот, который отображается в обычном браузере после нажатия CTRL-U.
* Ответ не содержит заголовков, чтобы получить заголовки, необходимо использовать действие 'Получить заголовок'.
* Вам нужно установить кодировку base64, если вы получаете двоичные данные. Многие действия принимают данные в формате base64.
* Вы можете указать точное название кодировки, см. список поддерживаемых кодировок https://doc.qt.io/qt-5/qtextcodec.html#details.
* Самый быстрый способ извлечь данные из кода страницы - xpath. http клиент имеет множество действий для выполнения xpath запросов. Не рекомендуется использовать действие 'Содержание ответа' и регулярные выражения, если только это не абсолютно необходимо.
* @param {string} encoding Кодировка
* @returns код страницы без заголовков
*/
function BAS_http_client_encoded_content(encoding) {
const encoding = _function_argument('encoding') || encoding
_switch_http_client_main()
const result = http_client_encoded_content(encoding)
_function_return(result)
return result
}
/**
* Стаутс ответа
* Получить статус последнего запроса http-клиента.
* Вы можете сравнить статус действием 'If', например VAR_SAVED_STATUS == 200. Это выражение проверяет, был ли запрос успешным.
* Список http-статусов https://www.webfx.com/web-development/glossary/http-status-codes/.
* @returns http статус как целое число
Примеры :
200 - Запрос завершился успешно.
302 - Целевая страница находится под другим адресом.
404 - Страница не найдена
*/
function BAS_http_client_status() {
_switch_http_client_main()
const result = http_client_status()
_function_return(result)
return result
}
/**
* Получить заголовок
* Получить заголовок из последнего запроса http клиента.
* Если запрос был выполнен с переадресацией, будут получены только заголовки для последнего перенаправления. Если вы хотите получить заголовки для запроса в середине цепочки, вам необходимо отключить опцию 'Следовать переадресациям' для действий 'GET' или 'POST' и выполнить перенаправления самостоятельно. Чтобы получить url следующего перенаправления, используйте действие 'Получить заголовок' с параметром 'Location'.
* Заголовки могут отображаться в инструментах разработчика браузера ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=showheaders.png).
* @param {string} header Имя заголовка
Имя заголовка ответа. Название заголовка должно содержать одно или несколько слов, разделенных дефисом. Реестр символов не важен.
Примеры :
Location - Получить заголовок 'Location'.
Content-Type - Получить заголовок 'Content-Type'.
cOnTeNt-tYpE - Также получает заголовок 'Content-Type'.
* @returns значение заголовка
*/
function BAS_http_client_header(header) {
const header = _function_argument('header') || header
_switch_http_client_main()
const result = http_client_header(header)
_function_return(result)
return result
}
/**
* HTTP-Клиент Установить Заголовок
* Установить заголовок запроса для всех последующих запросов с помощью http client.
* Вы можете установить любой допустимый заголовок, например 'User-Agent', 'Referer' и т. д. Однако, вот список заголовков, которые не следует задавать с помощью этого действия: 'Connection', 'Host', 'Content-Type'. 'Content-Type' должен быть установлен в действии 'POST' для каждого конкретного запроса. 'Accept-Encoding' может быть установлен, но запрещается помещать кодировку 'br' в список. Кодировка 'br' пока не поддерживается http клиентом.
* Чтобы гарантировать, что заголовки отправлены правильно, используйте инструмент 'HTTP анализ трафика', это окно, которое автоматически всплывает после любого http запроса в режиме записи ( скрин https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=httpsniffer.png).
* Используйте действие 'Очистить заголовки', если вы хотите отключить все заголовки, установленные этим действием.
* @param {string} header_name Имя заголовка
Название заголовка запроса. Оно должно содержать одно или несколько слов, разделенных дефисом.
Примеры :
User-Agent - Установить заголовок 'User-Agent'.
Accept-Language - Установить заголовок 'Accept-Language'.
Referer - Установить referer.
* @param {string} header_value Значение заголовка
Значение заголовка запроса. Это может быть произвольная строка.
*/
function BAS_http_client_set_header(header_name, header_value) {
const header_name = _function_argument('header_name') || header_name
const header_value = _function_argument('header_value') || header_value
_switch_http_client_main()
http_client_set_header(header_name, header_value)
}
/**
* Очистить заголовки
* Очистите все заголовки запросов, которые были установлены с помощью действия 'HTTP-Клиент Установить Заголовок'.
*/
function BAS_http_client_clear_header() {
_switch_http_client_main()
http_client_clear_header()
}
/**
* HTTP-Клиент Сохранить cookies
* Сохраните все cookies для http-клиента в переменную.
* В переменной будет содержаться строка в формате json со списоком всех cookies для всех доменов.
* Большинство сайтов использует cookies для хранения пользовательских данных, таких как авторизация пользователя. Это означает, что, сохраняя cookies после авторизации на каком-либо сайте и восстанавливая их позже, вы можете реализовать автовход на этом сайте.
* Cookies - это всего лишь строка, поэтому вы можете сохранить ее в файл или базу данных и использовать позже.
* Cookies из http-клиента могут быть отправлены в браузер даже без этого действия, используя 'Загрузить cookies из браузера'. Другое действие 'Загрузить cookies из http клиента' отправит cookies из http клиента в браузер.
* Cookies браузера и cookies http клиента имеют одинаковый формат.
* Строка cookies может быть преобразована в объект с помощью функции JSON.parse, например, VAR_JSON = JSON.parse (VAR_SAVED_COOKIES). Результат - это ассоциативный массив с одним ключом 'cookies', который содержит список, например {'cookies': [COOKIE1, COOKIE2, COOKIE3, ...]}. ( screen https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=cookiesformat2.png).
* Если вы хотите изменить cookies или получить от туда какие-то значения, вам необходимо использовать javascript. Код Javascript может быть выполнен в любом поле, если вы задаете тип поля как 'expression' или с помощью действия 'Выполнить код'.
* Каждый cookie представляет собой ассоциативный массив со следующими ключами: value, name, domain, path, expires, httpOnly, secure.
* secure и httpOnly - булевые значения.
* expires задает время жизни cookie, оно представлено как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года.
* Вот некоторые примеры кода для работы с cookies. Все они могут быть помещены в действие 'Выполнить код'. Прежде чем использовать их, вы должны получить объект cookies из строки, например так, VAR_COOKIES = JSON.parse(VAR_SAVED_COOKIES)["cookies"]
* Найти значение cookie по названию: VAR_COOKIE = VAR_COOKIES.filter(function(el){return el["name"] == "ЗАМЕНИТЬ НА НАЗВАНИЕ COOKIE"})[0]
* Проверить, существует ли cookie: VAR_COOKIE_EXISTS = VAR_COOKIES.filter(function(el){return el["name"] == "ЗАМЕНИТЬ НА НАЗВАНИЕ COOKIE"}).length > 0
* Получить значение cookie VAR_COOKIE_VALUE = VAR_COOKIE["value"]
* Вы также можете изменить значение cookie VAR_COOKIE["value"] = "My value". Но изменение этого объекта не повлечет за собой изменение cookies внутри http-клиента, для этого вам нужно преобразовать cookies в строку(с помощью JSON.stringify(VAR_COOKIES)) и использовать его с действием 'HTTP-Клиент Загрузить cookies'.
* Переменная VAR_COOKIES будет содержать список cookies, и так как это список, то его также можно обработать с помощью действий из модуля 'Список'.
* @returns строка в формате json со списоком всех cookies для всех доменов. Формат Json описан ниже.
*/
function BAS_http_client_save_cookies() {
_switch_http_client_main()
const result = http_client_save_cookies()
_function_return(result)
return result
}
/**
* HTTP-Клиент Загрузить cookies
* Установить cookies для http клиента.
* Параметр 'Cookies' должен содержать строку в формате json со списком cookies. Эта строка может быть получена как результат действия 'HTTP-Клиент Сохранить cookies' и также может быть изменена после этого если есть такая надобность.
* Большинство сайтов использует cookies для хранения пользовательских данных, таких как авторизация пользователя. Это означает, что, сохраняя cookies после авторизации на каком-либо сайте и восстанавливая их позже, вы можете реализовать автовход на этом сайте.
* Cookies - это всего лишь строка, поэтому вы можете сохранить ее в файл или базу данных и использовать позже.
* Cookies из http клиента могут быть отправлены в браузер, используя действие 'Загрузить cookies из http клиента', а действие 'Загрузить cookies из браузера' наоборот отправит cookies из браузера в http клиент.
* Cookies браузера и cookies http клиента имеют одинаковый формат.
* Cookies должны быть ассоциативным массивом с одним ключом 'cookies', который содержит список, например {'cookies': [COOKIE1, COOKIE2, COOKIE3, ...]}. ( скрин https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=cookiesformat2.png).
* Если вы хотите изменить cookies или получить от туда какие-то значения, вам необходимо использовать javascript. Код Javascript может быть выполнен в любом поле, если вы задаете тип поля как 'expression' или с помощью действия 'Выполнить код'.
* Каждый cookie представляет собой ассоциативный массив со следующими ключами: value, name, domain, path, expires, httpOnly, secure.
* secure и httpOnly - булевые значения.
* expires задает время жизни cookie, оно представлено как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года.
* Вот некоторые примеры кода для работы с cookies. Все они могут быть помещены в действие 'Выполнить код'. Прежде чем использовать их, вы должны получить объект cookies из строки, например так, VAR_COOKIES = JSON.parse(VAR_SAVED_COOKIES)["cookies"]
* Найти значение cookie по названию: VAR_COOKIE = VAR_COOKIES.filter(function(el){return el["name"] == "ЗАМЕНИТЬ НА НАЗВАНИЕ COOKIE"})[0]
* Проверить, существует ли cookie: VAR_COOKIE_EXISTS = VAR_COOKIES.filter(function(el){return el["name"] == "ЗАМЕНИТЬ НА НАЗВАНИЕ COOKIE"}).length > 0
* Получить значение cookie VAR_COOKIE_VALUE = VAR_COOKIE["value"]
* Вы также можете изменить значение cookie VAR_COOKIE["value"] = "My value".
* После того, как вы закончите редактирования списка VAR_COOKIES, вам нужно преобразовать его в строку с помощью кода JSON.stringify(VAR_COOKIES) ( скрин https://wiki.bablosoft.com/lib/exe/fetch.php?cache=&media=cookiesrestore2.png).
* Переменная VAR_COOKIES будет содержать список cookies, и так как это список, то его также можно обработать с помощью действий из модуля 'Список'.
* @param {string} cookies Cookies
Это поле должно содержать строку в формате json со списком всех cookies для всех доменов. Формат json описан ниже. Используйте пустую строку для очистки cookies.
Примеры :
Пустая строка - Удалить cookies
*/
function BAS_http_client_restore_cookies(cookies) {
_switch_http_client_main()
http_client_restore_cookies(cookies)
}
/**
* Загрузить cookies из браузера (BAS-функция)
* Загрузить cookies из браузера в http клиент.
* Большинство сайтов использует cookies для хранения пользовательских данных, таких как авторизация пользователя. Это означает, что, сохраняя cookies после авторизации на каком-либо сайте и восстанавливая их позже, вы можете реализовать автовход на этом сайте.
* Если процедура авторизации на сайте сложная, то она может быть выполнена с помощью браузера, а все остальное с помощью http клиента. Для этого после авторизации через браузер, cookies c помощью этого действия могут быть переданы в http клиент.
*/
function BAS_http_client_restore_cookies_from_browser() {
save_cookies()!
_switch_http_client_main()
http_client_restore_cookies(JSON.stringify({cookies:JSON.parse(_result())}))
}
/**
* Завершать работу после ошибки
* Это действие устарело, рекомендуется вместо него использовать 'Игнорировать ошибки'.
* @param {string} fail_on_error 'fail' | 'continue'
* Завершать работу после ошибки
*/
function BAS_http_client_set_fail_on_error(fail_on_error) {
_switch_http_client_main()
http_client_set_fail_on_error(fail_on_error === 'fail')
}
/**
* Была ли ошибка
* Это действие устарело, рекомендуется вместо него использовать 'Игнорировать ошибки'.
* @returns boolean
*/
function BAS_http_client_was_error() {
_switch_http_client_main()
const result = http_client_was_error()
_function_return(result)
return result
}
/**
* Получить текст ошибки
* Это действие устарело, рекомендуется вместо него использовать 'Игнорировать ошибки'.
* @returns string
*/
function BAS_http_client_error_string() {
_switch_http_client_main()
const result = http_client_error_string()
_function_return(result)
return result
}
/**
* Xpath получить xml
* Выполнить xpath запрос и найти xml первого элемента, который соответствует запросу.
* Это действие, в отличие от 'Xpath получить текст', ищет xml элемента(html-код).
* Если элемент не будет найден, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу после ошибки, используйте действие 'Игнорировать ошибки' или уберите флажок 'Завершать работу после ошибки'.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @param {boolean} do_not_fail Не завершать работу после ошибки
* @returns xml первого элемента, который соответствует xpath запросу
*/
function BAS_http_client_xpath_xml(query, do_not_fail) {
const query = _function_argument('query') || query
const do_not_fail = _function_argument('do_not_fail') || do_not_fail
_switch_http_client_main()
const result = http_client_xpath_xml(query, do_not_fail)
_function_return(result)
return result
}
/**
* Xpath получить каждый xml
* Выполнить xpath запрос и найти xml каждого элемента, соответствующего запросу.
* Это действие, в отличие от 'Xpath получить каждый текст', ищет именно xml элементов (html-код).
* Результатом этого действия является список, вы можете обработать его с помощью модуля 'Список'.
* Если ни один элемент не будет найден, то список будет пустым.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @param {boolean} do_not_fail Не завершать работу после ошибки
* @returns Список, который состоит из xml каждого найденного элемента
*/
function BAS_http_client_xpath_xml_list(query, do_not_fail) {
const query = _function_argument('query') || query
const do_not_fail = _function_argument('do_not_fail') || do_not_fail
_switch_http_client_main()
const result = http_client_xpath_xml_list(query, do_not_fail)
_function_return(result)
return result
}
/**
* Xpath получить текст
* Выполнить xpath запрос и найти текст первого элемента, который соответствует запросу.
* Результатом этого действия является текст. Например, если элемент имеет xml <div>word</div>, то его текст - 'word'.
* Если вы хотите получить xml элемента, используйте действие 'Xpath получить xml'.
* Если элемент не будет найден, поток остановится с сообщением об ошибке. Если вы хотите продолжить работу после ошибки, используйте действие 'Игнорировать ошибки' или уберите флажок 'Завершать работу после ошибки'.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @param {boolean} do_not_fail Не завершать работу после ошибки
* @returns Текст первого элемента, который соответствует xpath запросу
*/
function BAS_http_client_xpath_text(query, do_not_fail) {
const query = _function_argument('query') || query
const do_not_fail = _function_argument('do_not_fail') || do_not_fail
_switch_http_client_main()
const result = http_client_xpath_text(query, do_not_fail)
_function_return(result)
return result
}
/**
* Xpath получить каждый текст
* Выполнить xpath запрос и найти текст всех элементов, соответствующих запросу.
* Результатом этого действия является список, каждый элемент которого текст. Например, если элемент имеет xml <div>word</div>, то его текст - 'word'.
* Результатом этого действия является список, поэтому вы можете обработать его с помощью модуля 'Список'.
* Если ни один элемент не будет найден, то список будет пустым.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @param {boolean} do_not_fail Не завершать работу после ошибки
* @returns Список, который состоит из текста каждого найденного элемента
*/
function BAS_http_client_xpath_text_list(query, do_not_fail) {
const query = _function_argument('query') || query
const do_not_fail = _function_argument('do_not_fail') || do_not_fail
_switch_http_client_main()
const result = http_client_xpath_text_list(query, do_not_fail)
_function_return(result)
return result
}
/**
* Xpath получить количество элементов
* Выполнить xpath запрос и получить число элементов, которое ему соответствует.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @param {boolean} do_not_fail Не завершать работу после ошибки
* @returns количество элементов, соответствующих xpath запросу.
Примеры :
0 - Нет элементов, которые соответствуют запросу.
3 - Есть три элемента, которые соответствуют запросу.
*/
function BAS_http_client_xpath_count(query, do_not_fail) {
const query = _function_argument('query') || query
const do_not_fail = _function_argument('do_not_fail') || do_not_fail
_switch_http_client_main()
const result = http_client_xpath_count(query, do_not_fail)
_function_return(result)
return result
}
/**
* Xpath проверить существование
* Проверить, существует ли хотя бы один элемент, соответствующий xpath запросу.
* Html для применения запроса берется из последнего запроса http клиента.
* Если вы хотите применить xpath запрос к произвольной строке, а не к результату запроса http клиента, то вам нужно использовать модуль 'Xpath'.
* @param {string} query Xpath Запрос
Запрос Xpath
Примеры :
//title - Получить заголовок страницы.
//a - Получить все ссылки.
//img - Найти изображение.
//img/@src - Найти ссылку на изображение.
//*[@id='ID'] - Найти элемент по id.
//*[contains(@class,'CLASS')] - Найти элемент по классам. Элемент может иметь несколько классов, поэтому необходимо использовать функцию contains.
//*[contains(@class,'CLASS') and @id='ID'] - Найти элемент по классам и id.
//div[@id='ID_PARENT']/div[@id='ID_CHILD'] - Найдите элемент, содержащий родительский элемент.
* @returns true или false в зависимости от наличия элемента, который соответствует запросу.
Примеры :
true - Существует по крайней мере один элемент, который соответствует запросу.
false - Нет элементов, которые соответствуют запросу.
*/
function BAS_http_client_xpath_exists(query) {
const query = _function_argument('query') || query
_switch_http_client_main()
const result = http_client_xpath_exist(query)
_function_return(result)
return result
}
