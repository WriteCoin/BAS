const get_api_functions = (f) => {
	/**
* Игнорировать ошибки (BAS-функция)
* Игнорировать ошибки при выполнении одного или нескольких действий и продолжить выполнение скрипта дальше.
* Вы можете использовать переменную VAR_WAS_ERROR чтобы проверить, были ли ошибки во время последнего блока "Игнорировать Ошибки".
* В переменной VAR_LAST_ERROR содержится текст ошибки
* Фактически, эмуляция блока try/catch
* callback - функция выполнения действий в блоке try
* error_callback - функция выполнения действий в блоке catch
* error_message_func - функция, возвращающая сообщение об ошибке, вместо стандартного
* message_ignore_func - функция, возвращающая сообщение об игнорировани ошибок, в начале выполнения блока try, вместо стандартного
*/
const ignore_errors = async (params) => await f("ignore_errors", params)

	/**
* If (BAS-функция)
* Проверить заданное условие, если оно истинно, выполнить определенную последовательность действий, если оно ложно выполнить другую последовательность действий, наконец продолжить выполнение скрипта.
* cond_func - функция, возвращающая условие для проверки
* callback - функция при cond_func() равном true
* callback_else - функция "иначе" при cond_func(), равном false
*/
const BAS_if = async (params) => await f("BAS_if", params)

	/**
* While (BAS-функция)
* Выполнять заданный список действий пока какое-то условие является истинным.
* Эмуляция while.
* cond_func - функция условия подстановки в while
* callback - функция выполнения действий в блоке while
* message_func - функция, возвращающая строку сообщения в начале итерации цикла
*/
const BAS_while = async (params) => await f("BAS_while", params)

	/**
* Цикл For (BAS-функция)
* Выполнить определенный список действий заданное число раз.
* a и b - нижняя и верхняя границы цикла
* callback - функция действий
* message_func - функция, возвращающая сообщение, вместо стандартного
*/
const BAS_for = async (params) => await f("BAS_for", params)

	/**
* Выполнить заданный набор действий для каждого элемента массива.
* arrayList - входной массив, список
* callback - функция действий
* message_data_func - функция, возвращающая сообщение итерируемого значения массива, вместо стандартного
* message_index_func - функция, возвращающая индекс итерации массива, вместо стандартного
*/
const BAS_foreach = async (params) => await f("BAS_foreach", params)

	/**
* Немедленно прервать текущий цикл. Это действие работает только если оно помещено внутрь цикла(действия for, foreach, while).
* После выполнения этого действия цикл прерывается немедленно, текущий цикл не будет выполнен не единожды, а точка выполнения перемещается за следующие после цикла действие.
* Обычной практикой является помещение действия break внутрь действия if, таким образом цикл будет остановлен только при некоем условии
* @param {string} str Строка function для циклов
*/
const BAS_break = async (str) => await f("BAS_break", { str })

	/**
* Немедленно остановить текущее выполнение цикла и начать следующее. Это действие работает только если оно помещено внутрь цикла(действия for, foreach, while).
* После вызова этого действия текущее выполнение цикла прерывается немедленно, а точка выполнения перемещается в начало цикла
* @param {string} str Строка function для циклов
*/
const BAS_continue = async (str) => await f("BAS_continue", { str })

	/**
* Создать новую переменную или изменить существующую заданным значением.
Обычные переменные видимо только внутри текущего потока, используйте глобальные переменные если вы хотите сделай так, чтобы они были видимы во всех потоках.
Имя переменной должно быть написано большими латинскими буквами и отражать ее назначение. Называть переменные VAR_A1 или VAR_A2 не рекомендуется.
Созданную здесь переменную можно использовать позже если поместить ее имя в двойных квадратных скобках внутри любого поля: VAR_NEW_VARIABLE. Вам не нужно вводить это значение самостоятельно, просто нажмите на любое поле, затем на "Из переменной" и наконец выберите переменную из списка.
Параметр "Значение переменной" может содержать другие переменные, например VAR_LOGIN@gmail.сom или ресурсы. Так что это действие также может соединять строки(VAR_PART1VAR_PART2), обновлять их, и т. д.
По умолчанию параметр "Значение переменной" является строкой, но вы можете изменить его тип на int, так что переменная будет числом.
При установке типа в expression, в переменную будет записан результат выполнения джаваскрипт кода. Это очень мощный механизм. Например, чтобы получить текущее время, введите Date.now() в поле "Значение переменной" (screen)
Вы можете применять JavaScript функции к переменным BAS, например, код VAR_LINE.split(":")[0] разделит строку на части и возьмёт первый элемент.
Если вы хотите записать многострочную строку в переменную, используйте действие "Шаблон"
* @param {string} name имя глобальной переменной
* @param {number | string | boolean} value значение
*/
const BAS_set_global = async (name, value) => await f("BAS_set_global", { name, value })

	/**
* Получить значение глобальной переменной
* @param {string} name имя глобальной переменной
* @returns значение переменной
*/
const BAS_get_global = async (name) => await f("BAS_get_global", { name })

	/**
* Увеличить глобальную переменную
* @param {string} name имя глобальной переменной
* @param {number | string | boolean} val На сколько увеличить переменную
* Увеличить глобальную переменную на заданное значение.
Другими словами, это действие выполняет JSON.parse(P("basglobal", "VARIABLE") || '""') = JSON.parse(P("basglobal", "VARIABLE") || '""') + num
Это действие предполагает, что глобальная переменная будет иметь чисельний тип, если это не так, то тип переменной будет преобразован автоматически.
Параметр "На сколько увеличить переменную" может быть меньше нуля, в таком случае переменная будет уменьшена на это значение.
Параметр "На сколько увеличить переменную" также может быть равным нулю, это только преобразует тип переменной в чисельний.
*/
const BAS_inc_global = async (name, val) => await f("BAS_inc_global", { name, val })

	/**
* Распарсить CSV строку на элементы.
Это действие распарсит строку по указанным разделителям и сохранит распарсенные данные по указанным переменным.
Например, если указана строка "email@gmail.com:mypass1" и переменные USERNAME,PASSWORD, то действие сохранит "email@gmail.com" в переменную VAR_USERNAME и "mypass1" в переменную VAR_PASSWORD.
По умолчанию действие возвращает строки, но это можно изменить, включив параметр "Преобразовывать типы", находящийся в дополнительных настройках, тогда страки автоматически будут конвертироватся в числа, true или false, обекты, null и undefined.
Например, если указана строка "test:123:true", то в первую переменную будет сохранена строка "test", во вторую переменную число 123 и в третью переменную логическое значение true.
Если количество переменных больше, чем количество элементов в строке, то в лишние переменные будет записана пустая строка.
Используйте действие "Парсить строку" из модуля Список если хотите получить результат в виде списка.
* @param {string} str Строка
* @param {string} seps Список разделителей
* @param {Array} varList Список переменных
* @param {boolean} convert Преобразовывать типы
* @returns Объект с результатами
*/
const BAS_cvs_parse = async (str, seps, varList, convert) => await f("BAS_cvs_parse", { str, seps, varList, convert })

	/**
* Случайное Число
* Сгенерировать случайное целое число в заданном диапазоне.
* @param {number} a Минимальное Значение
* @param {number} b Максимальное Значение
* @returns Случайное число в указанном диапазоне
*/
const BAS_random = async (a, b) => await f("BAS_random", { a, b })

return {	ignore_errors,
	BAS_if,
	BAS_while,
	BAS_for,
	BAS_foreach,
	BAS_break,
	BAS_continue,
	BAS_set_global,
	BAS_get_global,
	BAS_inc_global,
	BAS_cvs_parse,
	BAS_random,
}
}

module.exports = get_api_functions